// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v1beta1/query.proto (package injective.exchange.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { ActiveGrant, AggregateAccountVolumeRecord, BinaryOptionsMarket, CampaignRewardPool, DenomDecimals, Deposit, DerivativeMarket, EffectiveGrant, ExpiryFuturesMarketInfo, FeeDiscountSchedule, FeeDiscountTierInfo, FeeDiscountTierTTL, GrantAuthorization, Level, MarketVolume, MidPriceAndTOB, Params, PerpetualMarketFunding, PerpetualMarketInfo, Position, SpotMarket, SubaccountOrderbookMetadata, SubaccountOrderData, TradeRecord, TradeRecords, TradingRewardCampaignInfo, VolumeRecord } from "./exchange_pb.js";
import { Balance, DerivativePosition, GenesisState } from "./genesis_pb.js";
import { MetadataStatistics } from "../../oracle/v1beta1/oracle_pb.js";

/**
 * @generated from enum injective.exchange.v1beta1.OrderSide
 */
export enum OrderSide {
  /**
   * will return both
   *
   * @generated from enum value: Side_Unspecified = 0;
   */
  Side_Unspecified = 0,

  /**
   * @generated from enum value: Buy = 1;
   */
  Buy = 1,

  /**
   * @generated from enum value: Sell = 2;
   */
  Sell = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderSide)
proto3.util.setEnumType(OrderSide, "injective.exchange.v1beta1.OrderSide", [
  { no: 0, name: "Side_Unspecified" },
  { no: 1, name: "Buy" },
  { no: 2, name: "Sell" },
]);

/**
 * CancellationStrategy is the list of cancellation strategies.
 *
 * @generated from enum injective.exchange.v1beta1.CancellationStrategy
 */
export enum CancellationStrategy {
  /**
   * just cancelling in random order in most efficient way
   *
   * @generated from enum value: UnspecifiedOrder = 0;
   */
  UnspecifiedOrder = 0,

  /**
   * e.g. for buy orders from lowest to highest price
   *
   * @generated from enum value: FromWorstToBest = 1;
   */
  FromWorstToBest = 1,

  /**
   * e.g. for buy orders from higest to lowest price
   *
   * @generated from enum value: FromBestToWorst = 2;
   */
  FromBestToWorst = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CancellationStrategy)
proto3.util.setEnumType(CancellationStrategy, "injective.exchange.v1beta1.CancellationStrategy", [
  { no: 0, name: "UnspecifiedOrder" },
  { no: 1, name: "FromWorstToBest" },
  { no: 2, name: "FromBestToWorst" },
]);

/**
 * @generated from message injective.exchange.v1beta1.Subaccount
 */
export class Subaccount extends Message<Subaccount> {
  /**
   * @generated from field: string trader = 1;
   */
  trader = "";

  /**
   * @generated from field: uint32 subaccount_nonce = 2;
   */
  subaccountNonce = 0;

  constructor(data?: PartialMessage<Subaccount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.Subaccount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trader", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_nonce", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subaccount {
    return new Subaccount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subaccount {
    return new Subaccount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subaccount {
    return new Subaccount().fromJsonString(jsonString, options);
  }

  static equals(a: Subaccount | PlainMessage<Subaccount> | undefined, b: Subaccount | PlainMessage<Subaccount> | undefined): boolean {
    return proto3.util.equals(Subaccount, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QuerySubaccountOrdersRequest
 */
export class QuerySubaccountOrdersRequest extends Message<QuerySubaccountOrdersRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string market_id = 2;
   */
  marketId = "";

  constructor(data?: PartialMessage<QuerySubaccountOrdersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountOrdersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountOrdersRequest {
    return new QuerySubaccountOrdersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountOrdersRequest {
    return new QuerySubaccountOrdersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountOrdersRequest {
    return new QuerySubaccountOrdersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountOrdersRequest | PlainMessage<QuerySubaccountOrdersRequest> | undefined, b: QuerySubaccountOrdersRequest | PlainMessage<QuerySubaccountOrdersRequest> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountOrdersRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QuerySubaccountOrdersResponse
 */
export class QuerySubaccountOrdersResponse extends Message<QuerySubaccountOrdersResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.SubaccountOrderData buy_orders = 1;
   */
  buyOrders: SubaccountOrderData[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.SubaccountOrderData sell_orders = 2;
   */
  sellOrders: SubaccountOrderData[] = [];

  constructor(data?: PartialMessage<QuerySubaccountOrdersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountOrdersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "buy_orders", kind: "message", T: SubaccountOrderData, repeated: true },
    { no: 2, name: "sell_orders", kind: "message", T: SubaccountOrderData, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountOrdersResponse {
    return new QuerySubaccountOrdersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountOrdersResponse {
    return new QuerySubaccountOrdersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountOrdersResponse {
    return new QuerySubaccountOrdersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountOrdersResponse | PlainMessage<QuerySubaccountOrdersResponse> | undefined, b: QuerySubaccountOrdersResponse | PlainMessage<QuerySubaccountOrdersResponse> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountOrdersResponse, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket
 */
export class SubaccountOrderbookMetadataWithMarket extends Message<SubaccountOrderbookMetadataWithMarket> {
  /**
   * @generated from field: injective.exchange.v1beta1.SubaccountOrderbookMetadata metadata = 1;
   */
  metadata?: SubaccountOrderbookMetadata;

  /**
   * @generated from field: string market_id = 2;
   */
  marketId = "";

  /**
   * @generated from field: bool isBuy = 3;
   */
  isBuy = false;

  constructor(data?: PartialMessage<SubaccountOrderbookMetadataWithMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: SubaccountOrderbookMetadata },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountOrderbookMetadataWithMarket {
    return new SubaccountOrderbookMetadataWithMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountOrderbookMetadataWithMarket {
    return new SubaccountOrderbookMetadataWithMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountOrderbookMetadataWithMarket {
    return new SubaccountOrderbookMetadataWithMarket().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountOrderbookMetadataWithMarket | PlainMessage<SubaccountOrderbookMetadataWithMarket> | undefined, b: SubaccountOrderbookMetadataWithMarket | PlainMessage<SubaccountOrderbookMetadataWithMarket> | undefined): boolean {
    return proto3.util.equals(SubaccountOrderbookMetadataWithMarket, a, b);
  }
}

/**
 * QueryExchangeParamsRequest is the request type for the Query/ExchangeParams
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExchangeParamsRequest
 */
export class QueryExchangeParamsRequest extends Message<QueryExchangeParamsRequest> {
  constructor(data?: PartialMessage<QueryExchangeParamsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryExchangeParamsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryExchangeParamsRequest {
    return new QueryExchangeParamsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryExchangeParamsRequest {
    return new QueryExchangeParamsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryExchangeParamsRequest {
    return new QueryExchangeParamsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryExchangeParamsRequest | PlainMessage<QueryExchangeParamsRequest> | undefined, b: QueryExchangeParamsRequest | PlainMessage<QueryExchangeParamsRequest> | undefined): boolean {
    return proto3.util.equals(QueryExchangeParamsRequest, a, b);
  }
}

/**
 * QueryExchangeParamsRequest is the response type for the Query/ExchangeParams
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExchangeParamsResponse
 */
export class QueryExchangeParamsResponse extends Message<QueryExchangeParamsResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.Params params = 1;
   */
  params?: Params;

  constructor(data?: PartialMessage<QueryExchangeParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryExchangeParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryExchangeParamsResponse {
    return new QueryExchangeParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryExchangeParamsResponse {
    return new QueryExchangeParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryExchangeParamsResponse {
    return new QueryExchangeParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryExchangeParamsResponse | PlainMessage<QueryExchangeParamsResponse> | undefined, b: QueryExchangeParamsResponse | PlainMessage<QueryExchangeParamsResponse> | undefined): boolean {
    return proto3.util.equals(QueryExchangeParamsResponse, a, b);
  }
}

/**
 * QuerySubaccountDepositsRequest is the request type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountDepositsRequest
 */
export class QuerySubaccountDepositsRequest extends Message<QuerySubaccountDepositsRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.Subaccount subaccount = 2;
   */
  subaccount?: Subaccount;

  constructor(data?: PartialMessage<QuerySubaccountDepositsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountDepositsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount", kind: "message", T: Subaccount },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountDepositsRequest {
    return new QuerySubaccountDepositsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountDepositsRequest {
    return new QuerySubaccountDepositsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountDepositsRequest {
    return new QuerySubaccountDepositsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountDepositsRequest | PlainMessage<QuerySubaccountDepositsRequest> | undefined, b: QuerySubaccountDepositsRequest | PlainMessage<QuerySubaccountDepositsRequest> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountDepositsRequest, a, b);
  }
}

/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountDepositsResponse
 */
export class QuerySubaccountDepositsResponse extends Message<QuerySubaccountDepositsResponse> {
  /**
   * @generated from field: map<string, injective.exchange.v1beta1.Deposit> deposits = 1;
   */
  deposits: { [key: string]: Deposit } = {};

  constructor(data?: PartialMessage<QuerySubaccountDepositsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountDepositsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deposits", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Deposit} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountDepositsResponse {
    return new QuerySubaccountDepositsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountDepositsResponse {
    return new QuerySubaccountDepositsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountDepositsResponse {
    return new QuerySubaccountDepositsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountDepositsResponse | PlainMessage<QuerySubaccountDepositsResponse> | undefined, b: QuerySubaccountDepositsResponse | PlainMessage<QuerySubaccountDepositsResponse> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountDepositsResponse, a, b);
  }
}

/**
 * QueryExchangeBalancesRequest is the request type for the
 * Query/ExchangeBalances RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExchangeBalancesRequest
 */
export class QueryExchangeBalancesRequest extends Message<QueryExchangeBalancesRequest> {
  constructor(data?: PartialMessage<QueryExchangeBalancesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryExchangeBalancesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryExchangeBalancesRequest {
    return new QueryExchangeBalancesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryExchangeBalancesRequest {
    return new QueryExchangeBalancesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryExchangeBalancesRequest {
    return new QueryExchangeBalancesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryExchangeBalancesRequest | PlainMessage<QueryExchangeBalancesRequest> | undefined, b: QueryExchangeBalancesRequest | PlainMessage<QueryExchangeBalancesRequest> | undefined): boolean {
    return proto3.util.equals(QueryExchangeBalancesRequest, a, b);
  }
}

/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExchangeBalancesResponse
 */
export class QueryExchangeBalancesResponse extends Message<QueryExchangeBalancesResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.Balance balances = 1;
   */
  balances: Balance[] = [];

  constructor(data?: PartialMessage<QueryExchangeBalancesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryExchangeBalancesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balances", kind: "message", T: Balance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryExchangeBalancesResponse {
    return new QueryExchangeBalancesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryExchangeBalancesResponse {
    return new QueryExchangeBalancesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryExchangeBalancesResponse {
    return new QueryExchangeBalancesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryExchangeBalancesResponse | PlainMessage<QueryExchangeBalancesResponse> | undefined, b: QueryExchangeBalancesResponse | PlainMessage<QueryExchangeBalancesResponse> | undefined): boolean {
    return proto3.util.equals(QueryExchangeBalancesResponse, a, b);
  }
}

/**
 * QueryAggregateVolumeRequest is the request type for the Query/AggregateVolume
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateVolumeRequest
 */
export class QueryAggregateVolumeRequest extends Message<QueryAggregateVolumeRequest> {
  /**
   * can either be an address or a subaccount
   *
   * @generated from field: string account = 1;
   */
  account = "";

  constructor(data?: PartialMessage<QueryAggregateVolumeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAggregateVolumeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAggregateVolumeRequest {
    return new QueryAggregateVolumeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAggregateVolumeRequest {
    return new QueryAggregateVolumeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAggregateVolumeRequest {
    return new QueryAggregateVolumeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAggregateVolumeRequest | PlainMessage<QueryAggregateVolumeRequest> | undefined, b: QueryAggregateVolumeRequest | PlainMessage<QueryAggregateVolumeRequest> | undefined): boolean {
    return proto3.util.equals(QueryAggregateVolumeRequest, a, b);
  }
}

/**
 * QueryAggregateVolumeResponse is the response type for the
 * Query/AggregateVolume RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateVolumeResponse
 */
export class QueryAggregateVolumeResponse extends Message<QueryAggregateVolumeResponse> {
  /**
   * if an address is specified, then the aggregate_volumes will aggregate the
   * volumes across all subaccounts for the address
   *
   * @generated from field: repeated injective.exchange.v1beta1.MarketVolume aggregate_volumes = 1;
   */
  aggregateVolumes: MarketVolume[] = [];

  constructor(data?: PartialMessage<QueryAggregateVolumeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAggregateVolumeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregate_volumes", kind: "message", T: MarketVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAggregateVolumeResponse {
    return new QueryAggregateVolumeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAggregateVolumeResponse {
    return new QueryAggregateVolumeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAggregateVolumeResponse {
    return new QueryAggregateVolumeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAggregateVolumeResponse | PlainMessage<QueryAggregateVolumeResponse> | undefined, b: QueryAggregateVolumeResponse | PlainMessage<QueryAggregateVolumeResponse> | undefined): boolean {
    return proto3.util.equals(QueryAggregateVolumeResponse, a, b);
  }
}

/**
 * QueryAggregateVolumesRequest is the request type for the
 * Query/AggregateVolumes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateVolumesRequest
 */
export class QueryAggregateVolumesRequest extends Message<QueryAggregateVolumesRequest> {
  /**
   * @generated from field: repeated string accounts = 1;
   */
  accounts: string[] = [];

  /**
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<QueryAggregateVolumesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAggregateVolumesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAggregateVolumesRequest {
    return new QueryAggregateVolumesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAggregateVolumesRequest {
    return new QueryAggregateVolumesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAggregateVolumesRequest {
    return new QueryAggregateVolumesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAggregateVolumesRequest | PlainMessage<QueryAggregateVolumesRequest> | undefined, b: QueryAggregateVolumesRequest | PlainMessage<QueryAggregateVolumesRequest> | undefined): boolean {
    return proto3.util.equals(QueryAggregateVolumesRequest, a, b);
  }
}

/**
 * QueryAggregateVolumesResponse is the response type for the
 * Query/AggregateVolumes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateVolumesResponse
 */
export class QueryAggregateVolumesResponse extends Message<QueryAggregateVolumesResponse> {
  /**
   * the aggregate volume records for the accounts specified
   *
   * @generated from field: repeated injective.exchange.v1beta1.AggregateAccountVolumeRecord aggregate_account_volumes = 1;
   */
  aggregateAccountVolumes: AggregateAccountVolumeRecord[] = [];

  /**
   * the aggregate volumes for the markets specified
   *
   * @generated from field: repeated injective.exchange.v1beta1.MarketVolume aggregate_market_volumes = 2;
   */
  aggregateMarketVolumes: MarketVolume[] = [];

  constructor(data?: PartialMessage<QueryAggregateVolumesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAggregateVolumesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregate_account_volumes", kind: "message", T: AggregateAccountVolumeRecord, repeated: true },
    { no: 2, name: "aggregate_market_volumes", kind: "message", T: MarketVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAggregateVolumesResponse {
    return new QueryAggregateVolumesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAggregateVolumesResponse {
    return new QueryAggregateVolumesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAggregateVolumesResponse {
    return new QueryAggregateVolumesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAggregateVolumesResponse | PlainMessage<QueryAggregateVolumesResponse> | undefined, b: QueryAggregateVolumesResponse | PlainMessage<QueryAggregateVolumesResponse> | undefined): boolean {
    return proto3.util.equals(QueryAggregateVolumesResponse, a, b);
  }
}

/**
 * QueryAggregateMarketVolumeRequest is the request type for the
 * Query/AggregateMarketVolume RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest
 */
export class QueryAggregateMarketVolumeRequest extends Message<QueryAggregateMarketVolumeRequest> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryAggregateMarketVolumeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAggregateMarketVolumeRequest {
    return new QueryAggregateMarketVolumeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAggregateMarketVolumeRequest {
    return new QueryAggregateMarketVolumeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAggregateMarketVolumeRequest {
    return new QueryAggregateMarketVolumeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAggregateMarketVolumeRequest | PlainMessage<QueryAggregateMarketVolumeRequest> | undefined, b: QueryAggregateMarketVolumeRequest | PlainMessage<QueryAggregateMarketVolumeRequest> | undefined): boolean {
    return proto3.util.equals(QueryAggregateMarketVolumeRequest, a, b);
  }
}

/**
 * QueryAggregateMarketVolumeResponse is the response type for the
 * Query/AggregateMarketVolume RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse
 */
export class QueryAggregateMarketVolumeResponse extends Message<QueryAggregateMarketVolumeResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.VolumeRecord volume = 1;
   */
  volume?: VolumeRecord;

  constructor(data?: PartialMessage<QueryAggregateMarketVolumeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "volume", kind: "message", T: VolumeRecord },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAggregateMarketVolumeResponse {
    return new QueryAggregateMarketVolumeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAggregateMarketVolumeResponse {
    return new QueryAggregateMarketVolumeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAggregateMarketVolumeResponse {
    return new QueryAggregateMarketVolumeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAggregateMarketVolumeResponse | PlainMessage<QueryAggregateMarketVolumeResponse> | undefined, b: QueryAggregateMarketVolumeResponse | PlainMessage<QueryAggregateMarketVolumeResponse> | undefined): boolean {
    return proto3.util.equals(QueryAggregateMarketVolumeResponse, a, b);
  }
}

/**
 * QueryDenomDecimalRequest is the request type for the Query/DenomDecimal RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDenomDecimalRequest
 */
export class QueryDenomDecimalRequest extends Message<QueryDenomDecimalRequest> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  constructor(data?: PartialMessage<QueryDenomDecimalRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDenomDecimalRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDenomDecimalRequest {
    return new QueryDenomDecimalRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDenomDecimalRequest {
    return new QueryDenomDecimalRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDenomDecimalRequest {
    return new QueryDenomDecimalRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDenomDecimalRequest | PlainMessage<QueryDenomDecimalRequest> | undefined, b: QueryDenomDecimalRequest | PlainMessage<QueryDenomDecimalRequest> | undefined): boolean {
    return proto3.util.equals(QueryDenomDecimalRequest, a, b);
  }
}

/**
 * QueryDenomDecimalResponse is the response type for the Query/DenomDecimal RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDenomDecimalResponse
 */
export class QueryDenomDecimalResponse extends Message<QueryDenomDecimalResponse> {
  /**
   * @generated from field: uint64 decimal = 1;
   */
  decimal = protoInt64.zero;

  constructor(data?: PartialMessage<QueryDenomDecimalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDenomDecimalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "decimal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDenomDecimalResponse {
    return new QueryDenomDecimalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDenomDecimalResponse {
    return new QueryDenomDecimalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDenomDecimalResponse {
    return new QueryDenomDecimalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDenomDecimalResponse | PlainMessage<QueryDenomDecimalResponse> | undefined, b: QueryDenomDecimalResponse | PlainMessage<QueryDenomDecimalResponse> | undefined): boolean {
    return proto3.util.equals(QueryDenomDecimalResponse, a, b);
  }
}

/**
 * QueryDenomDecimalsRequest is the request type for the Query/DenomDecimals RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDenomDecimalsRequest
 */
export class QueryDenomDecimalsRequest extends Message<QueryDenomDecimalsRequest> {
  /**
   * denoms can be empty to query all denom decimals
   *
   * @generated from field: repeated string denoms = 1;
   */
  denoms: string[] = [];

  constructor(data?: PartialMessage<QueryDenomDecimalsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDenomDecimalsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denoms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDenomDecimalsRequest {
    return new QueryDenomDecimalsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDenomDecimalsRequest {
    return new QueryDenomDecimalsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDenomDecimalsRequest {
    return new QueryDenomDecimalsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDenomDecimalsRequest | PlainMessage<QueryDenomDecimalsRequest> | undefined, b: QueryDenomDecimalsRequest | PlainMessage<QueryDenomDecimalsRequest> | undefined): boolean {
    return proto3.util.equals(QueryDenomDecimalsRequest, a, b);
  }
}

/**
 * QueryDenomDecimalsRequest is the response type for the Query/DenomDecimals
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDenomDecimalsResponse
 */
export class QueryDenomDecimalsResponse extends Message<QueryDenomDecimalsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.DenomDecimals denom_decimals = 1;
   */
  denomDecimals: DenomDecimals[] = [];

  constructor(data?: PartialMessage<QueryDenomDecimalsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDenomDecimalsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom_decimals", kind: "message", T: DenomDecimals, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDenomDecimalsResponse {
    return new QueryDenomDecimalsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDenomDecimalsResponse {
    return new QueryDenomDecimalsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDenomDecimalsResponse {
    return new QueryDenomDecimalsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDenomDecimalsResponse | PlainMessage<QueryDenomDecimalsResponse> | undefined, b: QueryDenomDecimalsResponse | PlainMessage<QueryDenomDecimalsResponse> | undefined): boolean {
    return proto3.util.equals(QueryDenomDecimalsResponse, a, b);
  }
}

/**
 * QueryAggregateMarketVolumesRequest is the request type for the
 * Query/AggregateMarketVolumes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest
 */
export class QueryAggregateMarketVolumesRequest extends Message<QueryAggregateMarketVolumesRequest> {
  /**
   * @generated from field: repeated string market_ids = 1;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<QueryAggregateMarketVolumesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAggregateMarketVolumesRequest {
    return new QueryAggregateMarketVolumesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAggregateMarketVolumesRequest {
    return new QueryAggregateMarketVolumesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAggregateMarketVolumesRequest {
    return new QueryAggregateMarketVolumesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAggregateMarketVolumesRequest | PlainMessage<QueryAggregateMarketVolumesRequest> | undefined, b: QueryAggregateMarketVolumesRequest | PlainMessage<QueryAggregateMarketVolumesRequest> | undefined): boolean {
    return proto3.util.equals(QueryAggregateMarketVolumesRequest, a, b);
  }
}

/**
 * QueryAggregateMarketVolumesResponse is the response type for the
 * Query/AggregateMarketVolumes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse
 */
export class QueryAggregateMarketVolumesResponse extends Message<QueryAggregateMarketVolumesResponse> {
  /**
   * the aggregate volumes for the entire market
   *
   * @generated from field: repeated injective.exchange.v1beta1.MarketVolume volumes = 1;
   */
  volumes: MarketVolume[] = [];

  constructor(data?: PartialMessage<QueryAggregateMarketVolumesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "volumes", kind: "message", T: MarketVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAggregateMarketVolumesResponse {
    return new QueryAggregateMarketVolumesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAggregateMarketVolumesResponse {
    return new QueryAggregateMarketVolumesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAggregateMarketVolumesResponse {
    return new QueryAggregateMarketVolumesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAggregateMarketVolumesResponse | PlainMessage<QueryAggregateMarketVolumesResponse> | undefined, b: QueryAggregateMarketVolumesResponse | PlainMessage<QueryAggregateMarketVolumesResponse> | undefined): boolean {
    return proto3.util.equals(QueryAggregateMarketVolumesResponse, a, b);
  }
}

/**
 * QuerySubaccountDepositsRequest is the request type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountDepositRequest
 */
export class QuerySubaccountDepositRequest extends Message<QuerySubaccountDepositRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string denom = 2;
   */
  denom = "";

  constructor(data?: PartialMessage<QuerySubaccountDepositRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountDepositRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountDepositRequest {
    return new QuerySubaccountDepositRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountDepositRequest {
    return new QuerySubaccountDepositRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountDepositRequest {
    return new QuerySubaccountDepositRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountDepositRequest | PlainMessage<QuerySubaccountDepositRequest> | undefined, b: QuerySubaccountDepositRequest | PlainMessage<QuerySubaccountDepositRequest> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountDepositRequest, a, b);
  }
}

/**
 * QuerySubaccountDepositsResponse is the response type for the
 * Query/SubaccountDeposits RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountDepositResponse
 */
export class QuerySubaccountDepositResponse extends Message<QuerySubaccountDepositResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.Deposit deposits = 1;
   */
  deposits?: Deposit;

  constructor(data?: PartialMessage<QuerySubaccountDepositResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountDepositResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deposits", kind: "message", T: Deposit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountDepositResponse {
    return new QuerySubaccountDepositResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountDepositResponse {
    return new QuerySubaccountDepositResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountDepositResponse {
    return new QuerySubaccountDepositResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountDepositResponse | PlainMessage<QuerySubaccountDepositResponse> | undefined, b: QuerySubaccountDepositResponse | PlainMessage<QuerySubaccountDepositResponse> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountDepositResponse, a, b);
  }
}

/**
 * QuerySpotMarketsRequest is the request type for the Query/SpotMarkets RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMarketsRequest
 */
export class QuerySpotMarketsRequest extends Message<QuerySpotMarketsRequest> {
  /**
   * Status of the market, for convenience it is set to string - not enum
   *
   * @generated from field: string status = 1;
   */
  status = "";

  /**
   * Filter by market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<QuerySpotMarketsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotMarketsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotMarketsRequest {
    return new QuerySpotMarketsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotMarketsRequest {
    return new QuerySpotMarketsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotMarketsRequest {
    return new QuerySpotMarketsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotMarketsRequest | PlainMessage<QuerySpotMarketsRequest> | undefined, b: QuerySpotMarketsRequest | PlainMessage<QuerySpotMarketsRequest> | undefined): boolean {
    return proto3.util.equals(QuerySpotMarketsRequest, a, b);
  }
}

/**
 * QuerySpotMarketsResponse is the response type for the Query/SpotMarkets RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMarketsResponse
 */
export class QuerySpotMarketsResponse extends Message<QuerySpotMarketsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.SpotMarket markets = 1;
   */
  markets: SpotMarket[] = [];

  constructor(data?: PartialMessage<QuerySpotMarketsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotMarketsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "markets", kind: "message", T: SpotMarket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotMarketsResponse {
    return new QuerySpotMarketsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotMarketsResponse {
    return new QuerySpotMarketsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotMarketsResponse {
    return new QuerySpotMarketsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotMarketsResponse | PlainMessage<QuerySpotMarketsResponse> | undefined, b: QuerySpotMarketsResponse | PlainMessage<QuerySpotMarketsResponse> | undefined): boolean {
    return proto3.util.equals(QuerySpotMarketsResponse, a, b);
  }
}

/**
 * QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMarketRequest
 */
export class QuerySpotMarketRequest extends Message<QuerySpotMarketRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QuerySpotMarketRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotMarketRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotMarketRequest {
    return new QuerySpotMarketRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotMarketRequest {
    return new QuerySpotMarketRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotMarketRequest {
    return new QuerySpotMarketRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotMarketRequest | PlainMessage<QuerySpotMarketRequest> | undefined, b: QuerySpotMarketRequest | PlainMessage<QuerySpotMarketRequest> | undefined): boolean {
    return proto3.util.equals(QuerySpotMarketRequest, a, b);
  }
}

/**
 * QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMarketResponse
 */
export class QuerySpotMarketResponse extends Message<QuerySpotMarketResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.SpotMarket market = 1;
   */
  market?: SpotMarket;

  constructor(data?: PartialMessage<QuerySpotMarketResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotMarketResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: SpotMarket },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotMarketResponse {
    return new QuerySpotMarketResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotMarketResponse {
    return new QuerySpotMarketResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotMarketResponse {
    return new QuerySpotMarketResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotMarketResponse | PlainMessage<QuerySpotMarketResponse> | undefined, b: QuerySpotMarketResponse | PlainMessage<QuerySpotMarketResponse> | undefined): boolean {
    return proto3.util.equals(QuerySpotMarketResponse, a, b);
  }
}

/**
 * QuerySpotOrderbookRequest is the request type for the Query/SpotOrderbook RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotOrderbookRequest
 */
export class QuerySpotOrderbookRequest extends Message<QuerySpotOrderbookRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: uint64 limit = 2;
   */
  limit = protoInt64.zero;

  /**
   * @generated from field: injective.exchange.v1beta1.OrderSide order_side = 3;
   */
  orderSide = OrderSide.Side_Unspecified;

  /**
   * @generated from field: string limit_cumulative_notional = 4;
   */
  limitCumulativeNotional = "";

  /**
   * @generated from field: string limit_cumulative_quantity = 5;
   */
  limitCumulativeQuantity = "";

  constructor(data?: PartialMessage<QuerySpotOrderbookRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotOrderbookRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "order_side", kind: "enum", T: proto3.getEnumType(OrderSide) },
    { no: 4, name: "limit_cumulative_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "limit_cumulative_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotOrderbookRequest {
    return new QuerySpotOrderbookRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotOrderbookRequest {
    return new QuerySpotOrderbookRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotOrderbookRequest {
    return new QuerySpotOrderbookRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotOrderbookRequest | PlainMessage<QuerySpotOrderbookRequest> | undefined, b: QuerySpotOrderbookRequest | PlainMessage<QuerySpotOrderbookRequest> | undefined): boolean {
    return proto3.util.equals(QuerySpotOrderbookRequest, a, b);
  }
}

/**
 * QuerySpotOrderbookResponse is the response type for the Query/SpotOrderbook
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotOrderbookResponse
 */
export class QuerySpotOrderbookResponse extends Message<QuerySpotOrderbookResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.Level buys_price_level = 1;
   */
  buysPriceLevel: Level[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.Level sells_price_level = 2;
   */
  sellsPriceLevel: Level[] = [];

  constructor(data?: PartialMessage<QuerySpotOrderbookResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotOrderbookResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "buys_price_level", kind: "message", T: Level, repeated: true },
    { no: 2, name: "sells_price_level", kind: "message", T: Level, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotOrderbookResponse {
    return new QuerySpotOrderbookResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotOrderbookResponse {
    return new QuerySpotOrderbookResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotOrderbookResponse {
    return new QuerySpotOrderbookResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotOrderbookResponse | PlainMessage<QuerySpotOrderbookResponse> | undefined, b: QuerySpotOrderbookResponse | PlainMessage<QuerySpotOrderbookResponse> | undefined): boolean {
    return proto3.util.equals(QuerySpotOrderbookResponse, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.FullSpotMarket
 */
export class FullSpotMarket extends Message<FullSpotMarket> {
  /**
   * @generated from field: injective.exchange.v1beta1.SpotMarket market = 1;
   */
  market?: SpotMarket;

  /**
   * mid_price_and_tob defines the mid price for this market and the best ask
   * and bid orders
   *
   * @generated from field: injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 2;
   */
  midPriceAndTob?: MidPriceAndTOB;

  constructor(data?: PartialMessage<FullSpotMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.FullSpotMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: SpotMarket },
    { no: 2, name: "mid_price_and_tob", kind: "message", T: MidPriceAndTOB },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FullSpotMarket {
    return new FullSpotMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FullSpotMarket {
    return new FullSpotMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FullSpotMarket {
    return new FullSpotMarket().fromJsonString(jsonString, options);
  }

  static equals(a: FullSpotMarket | PlainMessage<FullSpotMarket> | undefined, b: FullSpotMarket | PlainMessage<FullSpotMarket> | undefined): boolean {
    return proto3.util.equals(FullSpotMarket, a, b);
  }
}

/**
 * QueryFullSpotMarketsRequest is the request type for the Query/FullSpotMarkets
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFullSpotMarketsRequest
 */
export class QueryFullSpotMarketsRequest extends Message<QueryFullSpotMarketsRequest> {
  /**
   * Status of the market, for convenience it is set to string - not enum
   *
   * @generated from field: string status = 1;
   */
  status = "";

  /**
   * Filter by market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  /**
   * Flag to return the markets mid price and top of the book buy and sell
   * orders.
   *
   * @generated from field: bool with_mid_price_and_tob = 3;
   */
  withMidPriceAndTob = false;

  constructor(data?: PartialMessage<QueryFullSpotMarketsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFullSpotMarketsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFullSpotMarketsRequest {
    return new QueryFullSpotMarketsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFullSpotMarketsRequest {
    return new QueryFullSpotMarketsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFullSpotMarketsRequest {
    return new QueryFullSpotMarketsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFullSpotMarketsRequest | PlainMessage<QueryFullSpotMarketsRequest> | undefined, b: QueryFullSpotMarketsRequest | PlainMessage<QueryFullSpotMarketsRequest> | undefined): boolean {
    return proto3.util.equals(QueryFullSpotMarketsRequest, a, b);
  }
}

/**
 * QueryFullSpotMarketsResponse is the response type for the
 * Query/FullSpotMarkets RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFullSpotMarketsResponse
 */
export class QueryFullSpotMarketsResponse extends Message<QueryFullSpotMarketsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.FullSpotMarket markets = 1;
   */
  markets: FullSpotMarket[] = [];

  constructor(data?: PartialMessage<QueryFullSpotMarketsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFullSpotMarketsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "markets", kind: "message", T: FullSpotMarket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFullSpotMarketsResponse {
    return new QueryFullSpotMarketsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFullSpotMarketsResponse {
    return new QueryFullSpotMarketsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFullSpotMarketsResponse {
    return new QueryFullSpotMarketsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFullSpotMarketsResponse | PlainMessage<QueryFullSpotMarketsResponse> | undefined, b: QueryFullSpotMarketsResponse | PlainMessage<QueryFullSpotMarketsResponse> | undefined): boolean {
    return proto3.util.equals(QueryFullSpotMarketsResponse, a, b);
  }
}

/**
 * QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFullSpotMarketRequest
 */
export class QueryFullSpotMarketRequest extends Message<QueryFullSpotMarketRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * Flag to return the markets mid price and top of the book buy and sell
   * orders.
   *
   * @generated from field: bool with_mid_price_and_tob = 2;
   */
  withMidPriceAndTob = false;

  constructor(data?: PartialMessage<QueryFullSpotMarketRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFullSpotMarketRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFullSpotMarketRequest {
    return new QueryFullSpotMarketRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFullSpotMarketRequest {
    return new QueryFullSpotMarketRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFullSpotMarketRequest {
    return new QueryFullSpotMarketRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFullSpotMarketRequest | PlainMessage<QueryFullSpotMarketRequest> | undefined, b: QueryFullSpotMarketRequest | PlainMessage<QueryFullSpotMarketRequest> | undefined): boolean {
    return proto3.util.equals(QueryFullSpotMarketRequest, a, b);
  }
}

/**
 * QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFullSpotMarketResponse
 */
export class QueryFullSpotMarketResponse extends Message<QueryFullSpotMarketResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.FullSpotMarket market = 1;
   */
  market?: FullSpotMarket;

  constructor(data?: PartialMessage<QueryFullSpotMarketResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFullSpotMarketResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: FullSpotMarket },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFullSpotMarketResponse {
    return new QueryFullSpotMarketResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFullSpotMarketResponse {
    return new QueryFullSpotMarketResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFullSpotMarketResponse {
    return new QueryFullSpotMarketResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFullSpotMarketResponse | PlainMessage<QueryFullSpotMarketResponse> | undefined, b: QueryFullSpotMarketResponse | PlainMessage<QueryFullSpotMarketResponse> | undefined): boolean {
    return proto3.util.equals(QueryFullSpotMarketResponse, a, b);
  }
}

/**
 * QuerySpotOrdersByHashesRequest is the request type for the
 * Query/SpotOrdersByHashes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest
 */
export class QuerySpotOrdersByHashesRequest extends Message<QuerySpotOrdersByHashesRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * SubaccountID of the trader
   *
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  /**
   * the order hashes
   *
   * @generated from field: repeated string order_hashes = 3;
   */
  orderHashes: string[] = [];

  constructor(data?: PartialMessage<QuerySpotOrdersByHashesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_hashes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotOrdersByHashesRequest {
    return new QuerySpotOrdersByHashesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotOrdersByHashesRequest {
    return new QuerySpotOrdersByHashesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotOrdersByHashesRequest {
    return new QuerySpotOrdersByHashesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotOrdersByHashesRequest | PlainMessage<QuerySpotOrdersByHashesRequest> | undefined, b: QuerySpotOrdersByHashesRequest | PlainMessage<QuerySpotOrdersByHashesRequest> | undefined): boolean {
    return proto3.util.equals(QuerySpotOrdersByHashesRequest, a, b);
  }
}

/**
 * QuerySpotOrdersByHashesResponse is the response type for the
 * Query/SpotOrdersByHashes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse
 */
export class QuerySpotOrdersByHashesResponse extends Message<QuerySpotOrdersByHashesResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;
   */
  orders: TrimmedSpotLimitOrder[] = [];

  constructor(data?: PartialMessage<QuerySpotOrdersByHashesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedSpotLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotOrdersByHashesResponse {
    return new QuerySpotOrdersByHashesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotOrdersByHashesResponse {
    return new QuerySpotOrdersByHashesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotOrdersByHashesResponse {
    return new QuerySpotOrdersByHashesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotOrdersByHashesResponse | PlainMessage<QuerySpotOrdersByHashesResponse> | undefined, b: QuerySpotOrdersByHashesResponse | PlainMessage<QuerySpotOrdersByHashesResponse> | undefined): boolean {
    return proto3.util.equals(QuerySpotOrdersByHashesResponse, a, b);
  }
}

/**
 * QueryTraderSpotOrdersRequest is the request type for the
 * Query/TraderSpotOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderSpotOrdersRequest
 */
export class QueryTraderSpotOrdersRequest extends Message<QueryTraderSpotOrdersRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * SubaccountID of the trader
   *
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  constructor(data?: PartialMessage<QueryTraderSpotOrdersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTraderSpotOrdersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraderSpotOrdersRequest {
    return new QueryTraderSpotOrdersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraderSpotOrdersRequest {
    return new QueryTraderSpotOrdersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraderSpotOrdersRequest {
    return new QueryTraderSpotOrdersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraderSpotOrdersRequest | PlainMessage<QueryTraderSpotOrdersRequest> | undefined, b: QueryTraderSpotOrdersRequest | PlainMessage<QueryTraderSpotOrdersRequest> | undefined): boolean {
    return proto3.util.equals(QueryTraderSpotOrdersRequest, a, b);
  }
}

/**
 * QueryAccountAddressSpotOrdersRequest is the request type for the
 * Query/AccountAddressSpotOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest
 */
export class QueryAccountAddressSpotOrdersRequest extends Message<QueryAccountAddressSpotOrdersRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * Account address of the trader
   *
   * @generated from field: string account_address = 2;
   */
  accountAddress = "";

  constructor(data?: PartialMessage<QueryAccountAddressSpotOrdersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAccountAddressSpotOrdersRequest {
    return new QueryAccountAddressSpotOrdersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAccountAddressSpotOrdersRequest {
    return new QueryAccountAddressSpotOrdersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAccountAddressSpotOrdersRequest {
    return new QueryAccountAddressSpotOrdersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAccountAddressSpotOrdersRequest | PlainMessage<QueryAccountAddressSpotOrdersRequest> | undefined, b: QueryAccountAddressSpotOrdersRequest | PlainMessage<QueryAccountAddressSpotOrdersRequest> | undefined): boolean {
    return proto3.util.equals(QueryAccountAddressSpotOrdersRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TrimmedSpotLimitOrder
 */
export class TrimmedSpotLimitOrder extends Message<TrimmedSpotLimitOrder> {
  /**
   * price of the order
   *
   * @generated from field: string price = 1;
   */
  price = "";

  /**
   * quantity of the order
   *
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string fillable = 3;
   */
  fillable = "";

  /**
   * true if the order is a buy
   *
   * @generated from field: bool isBuy = 4;
   */
  isBuy = false;

  /**
   * @generated from field: string order_hash = 5;
   */
  orderHash = "";

  /**
   * @generated from field: string cid = 6;
   */
  cid = "";

  constructor(data?: PartialMessage<TrimmedSpotLimitOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TrimmedSpotLimitOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrimmedSpotLimitOrder {
    return new TrimmedSpotLimitOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrimmedSpotLimitOrder {
    return new TrimmedSpotLimitOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrimmedSpotLimitOrder {
    return new TrimmedSpotLimitOrder().fromJsonString(jsonString, options);
  }

  static equals(a: TrimmedSpotLimitOrder | PlainMessage<TrimmedSpotLimitOrder> | undefined, b: TrimmedSpotLimitOrder | PlainMessage<TrimmedSpotLimitOrder> | undefined): boolean {
    return proto3.util.equals(TrimmedSpotLimitOrder, a, b);
  }
}

/**
 * QueryTraderSpotOrdersResponse is the response type for the
 * Query/TraderSpotOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderSpotOrdersResponse
 */
export class QueryTraderSpotOrdersResponse extends Message<QueryTraderSpotOrdersResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;
   */
  orders: TrimmedSpotLimitOrder[] = [];

  constructor(data?: PartialMessage<QueryTraderSpotOrdersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTraderSpotOrdersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedSpotLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraderSpotOrdersResponse {
    return new QueryTraderSpotOrdersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraderSpotOrdersResponse {
    return new QueryTraderSpotOrdersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraderSpotOrdersResponse {
    return new QueryTraderSpotOrdersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraderSpotOrdersResponse | PlainMessage<QueryTraderSpotOrdersResponse> | undefined, b: QueryTraderSpotOrdersResponse | PlainMessage<QueryTraderSpotOrdersResponse> | undefined): boolean {
    return proto3.util.equals(QueryTraderSpotOrdersResponse, a, b);
  }
}

/**
 * QueryAccountAddressSpotOrdersResponse is the response type for the
 * Query/AccountAddressSpotOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse
 */
export class QueryAccountAddressSpotOrdersResponse extends Message<QueryAccountAddressSpotOrdersResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;
   */
  orders: TrimmedSpotLimitOrder[] = [];

  constructor(data?: PartialMessage<QueryAccountAddressSpotOrdersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedSpotLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAccountAddressSpotOrdersResponse {
    return new QueryAccountAddressSpotOrdersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAccountAddressSpotOrdersResponse {
    return new QueryAccountAddressSpotOrdersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAccountAddressSpotOrdersResponse {
    return new QueryAccountAddressSpotOrdersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAccountAddressSpotOrdersResponse | PlainMessage<QueryAccountAddressSpotOrdersResponse> | undefined, b: QueryAccountAddressSpotOrdersResponse | PlainMessage<QueryAccountAddressSpotOrdersResponse> | undefined): boolean {
    return proto3.util.equals(QueryAccountAddressSpotOrdersResponse, a, b);
  }
}

/**
 * QuerySpotMidPriceAndTOBRequest is the request type for the
 * Query/SpotMidPriceAndTOB RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest
 */
export class QuerySpotMidPriceAndTOBRequest extends Message<QuerySpotMidPriceAndTOBRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QuerySpotMidPriceAndTOBRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotMidPriceAndTOBRequest {
    return new QuerySpotMidPriceAndTOBRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotMidPriceAndTOBRequest {
    return new QuerySpotMidPriceAndTOBRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotMidPriceAndTOBRequest {
    return new QuerySpotMidPriceAndTOBRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotMidPriceAndTOBRequest | PlainMessage<QuerySpotMidPriceAndTOBRequest> | undefined, b: QuerySpotMidPriceAndTOBRequest | PlainMessage<QuerySpotMidPriceAndTOBRequest> | undefined): boolean {
    return proto3.util.equals(QuerySpotMidPriceAndTOBRequest, a, b);
  }
}

/**
 * QuerySpotMidPriceAndTOBResponse is the response type for the
 * Query/SpotMidPriceAndTOB RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse
 */
export class QuerySpotMidPriceAndTOBResponse extends Message<QuerySpotMidPriceAndTOBResponse> {
  /**
   * mid price of the market
   *
   * @generated from field: string mid_price = 1;
   */
  midPrice = "";

  /**
   * best buy price of the market
   *
   * @generated from field: string best_buy_price = 2;
   */
  bestBuyPrice = "";

  /**
   * best sell price of the market
   *
   * @generated from field: string best_sell_price = 3;
   */
  bestSellPrice = "";

  constructor(data?: PartialMessage<QuerySpotMidPriceAndTOBResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mid_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySpotMidPriceAndTOBResponse {
    return new QuerySpotMidPriceAndTOBResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySpotMidPriceAndTOBResponse {
    return new QuerySpotMidPriceAndTOBResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySpotMidPriceAndTOBResponse {
    return new QuerySpotMidPriceAndTOBResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySpotMidPriceAndTOBResponse | PlainMessage<QuerySpotMidPriceAndTOBResponse> | undefined, b: QuerySpotMidPriceAndTOBResponse | PlainMessage<QuerySpotMidPriceAndTOBResponse> | undefined): boolean {
    return proto3.util.equals(QuerySpotMidPriceAndTOBResponse, a, b);
  }
}

/**
 * QueryDerivativeMidPriceAndTOBRequest is the request type for the
 * Query/GetDerivativeMidPriceAndTOB RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest
 */
export class QueryDerivativeMidPriceAndTOBRequest extends Message<QueryDerivativeMidPriceAndTOBRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryDerivativeMidPriceAndTOBRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeMidPriceAndTOBRequest {
    return new QueryDerivativeMidPriceAndTOBRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeMidPriceAndTOBRequest {
    return new QueryDerivativeMidPriceAndTOBRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeMidPriceAndTOBRequest {
    return new QueryDerivativeMidPriceAndTOBRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeMidPriceAndTOBRequest | PlainMessage<QueryDerivativeMidPriceAndTOBRequest> | undefined, b: QueryDerivativeMidPriceAndTOBRequest | PlainMessage<QueryDerivativeMidPriceAndTOBRequest> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeMidPriceAndTOBRequest, a, b);
  }
}

/**
 * QueryDerivativeMidPriceAndTOBResponse is the response type for the
 * Query/GetDerivativeMidPriceAndTOB RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse
 */
export class QueryDerivativeMidPriceAndTOBResponse extends Message<QueryDerivativeMidPriceAndTOBResponse> {
  /**
   * mid price of the market
   *
   * @generated from field: string mid_price = 1;
   */
  midPrice = "";

  /**
   * best buy price of the market
   *
   * @generated from field: string best_buy_price = 2;
   */
  bestBuyPrice = "";

  /**
   * best sell price of the market
   *
   * @generated from field: string best_sell_price = 3;
   */
  bestSellPrice = "";

  constructor(data?: PartialMessage<QueryDerivativeMidPriceAndTOBResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mid_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeMidPriceAndTOBResponse {
    return new QueryDerivativeMidPriceAndTOBResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeMidPriceAndTOBResponse {
    return new QueryDerivativeMidPriceAndTOBResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeMidPriceAndTOBResponse {
    return new QueryDerivativeMidPriceAndTOBResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeMidPriceAndTOBResponse | PlainMessage<QueryDerivativeMidPriceAndTOBResponse> | undefined, b: QueryDerivativeMidPriceAndTOBResponse | PlainMessage<QueryDerivativeMidPriceAndTOBResponse> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeMidPriceAndTOBResponse, a, b);
  }
}

/**
 * QueryDerivativeOrderbookRequest is the request type for the
 * Query/DerivativeOrderbook RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeOrderbookRequest
 */
export class QueryDerivativeOrderbookRequest extends Message<QueryDerivativeOrderbookRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: uint64 limit = 2;
   */
  limit = protoInt64.zero;

  /**
   * @generated from field: string limit_cumulative_notional = 3;
   */
  limitCumulativeNotional = "";

  constructor(data?: PartialMessage<QueryDerivativeOrderbookRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeOrderbookRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "limit_cumulative_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeOrderbookRequest {
    return new QueryDerivativeOrderbookRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeOrderbookRequest {
    return new QueryDerivativeOrderbookRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeOrderbookRequest {
    return new QueryDerivativeOrderbookRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeOrderbookRequest | PlainMessage<QueryDerivativeOrderbookRequest> | undefined, b: QueryDerivativeOrderbookRequest | PlainMessage<QueryDerivativeOrderbookRequest> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeOrderbookRequest, a, b);
  }
}

/**
 * QueryDerivativeOrderbookResponse is the response type for the
 * Query/DerivativeOrderbook RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeOrderbookResponse
 */
export class QueryDerivativeOrderbookResponse extends Message<QueryDerivativeOrderbookResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.Level buys_price_level = 1;
   */
  buysPriceLevel: Level[] = [];

  /**
   * @generated from field: repeated injective.exchange.v1beta1.Level sells_price_level = 2;
   */
  sellsPriceLevel: Level[] = [];

  constructor(data?: PartialMessage<QueryDerivativeOrderbookResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeOrderbookResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "buys_price_level", kind: "message", T: Level, repeated: true },
    { no: 2, name: "sells_price_level", kind: "message", T: Level, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeOrderbookResponse {
    return new QueryDerivativeOrderbookResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeOrderbookResponse {
    return new QueryDerivativeOrderbookResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeOrderbookResponse {
    return new QueryDerivativeOrderbookResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeOrderbookResponse | PlainMessage<QueryDerivativeOrderbookResponse> | undefined, b: QueryDerivativeOrderbookResponse | PlainMessage<QueryDerivativeOrderbookResponse> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeOrderbookResponse, a, b);
  }
}

/**
 * QueryTraderSpotOrdersToCancelUpToAmountRequest is the request type for the
 * Query/TraderSpotOrdersToCancelUpToAmountRequest RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest
 */
export class QueryTraderSpotOrdersToCancelUpToAmountRequest extends Message<QueryTraderSpotOrdersToCancelUpToAmountRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * SubaccountID of the trader
   *
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  /**
   * the base amount to cancel (free up)
   *
   * @generated from field: string base_amount = 3;
   */
  baseAmount = "";

  /**
   * the quote amount to cancel (free up)
   *
   * @generated from field: string quote_amount = 4;
   */
  quoteAmount = "";

  /**
   * The cancellation strategy
   *
   * @generated from field: injective.exchange.v1beta1.CancellationStrategy strategy = 5;
   */
  strategy = CancellationStrategy.UnspecifiedOrder;

  /**
   * The reference price for the cancellation strategy, e.g. mid price or mark
   * price
   *
   * @generated from field: string reference_price = 6;
   */
  referencePrice = "";

  constructor(data?: PartialMessage<QueryTraderSpotOrdersToCancelUpToAmountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "base_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "quote_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "strategy", kind: "enum", T: proto3.getEnumType(CancellationStrategy) },
    { no: 6, name: "reference_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraderSpotOrdersToCancelUpToAmountRequest {
    return new QueryTraderSpotOrdersToCancelUpToAmountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraderSpotOrdersToCancelUpToAmountRequest {
    return new QueryTraderSpotOrdersToCancelUpToAmountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraderSpotOrdersToCancelUpToAmountRequest {
    return new QueryTraderSpotOrdersToCancelUpToAmountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraderSpotOrdersToCancelUpToAmountRequest | PlainMessage<QueryTraderSpotOrdersToCancelUpToAmountRequest> | undefined, b: QueryTraderSpotOrdersToCancelUpToAmountRequest | PlainMessage<QueryTraderSpotOrdersToCancelUpToAmountRequest> | undefined): boolean {
    return proto3.util.equals(QueryTraderSpotOrdersToCancelUpToAmountRequest, a, b);
  }
}

/**
 * QueryTraderDerivativeOrdersToCancelUpToAmountRequest is the request type for
 * the Query/TraderDerivativeOrdersToCancelUpToAmountRequest RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest
 */
export class QueryTraderDerivativeOrdersToCancelUpToAmountRequest extends Message<QueryTraderDerivativeOrdersToCancelUpToAmountRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * SubaccountID of the trader
   *
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  /**
   * the quote amount to cancel (free up)
   *
   * @generated from field: string quote_amount = 3;
   */
  quoteAmount = "";

  /**
   * The cancellation strategy
   *
   * @generated from field: injective.exchange.v1beta1.CancellationStrategy strategy = 4;
   */
  strategy = CancellationStrategy.UnspecifiedOrder;

  /**
   * The reference price for the cancellation strategy, e.g. mid price or mark
   * price
   *
   * @generated from field: string reference_price = 5;
   */
  referencePrice = "";

  constructor(data?: PartialMessage<QueryTraderDerivativeOrdersToCancelUpToAmountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quote_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "strategy", kind: "enum", T: proto3.getEnumType(CancellationStrategy) },
    { no: 5, name: "reference_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    return new QueryTraderDerivativeOrdersToCancelUpToAmountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    return new QueryTraderDerivativeOrdersToCancelUpToAmountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    return new QueryTraderDerivativeOrdersToCancelUpToAmountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraderDerivativeOrdersToCancelUpToAmountRequest | PlainMessage<QueryTraderDerivativeOrdersToCancelUpToAmountRequest> | undefined, b: QueryTraderDerivativeOrdersToCancelUpToAmountRequest | PlainMessage<QueryTraderDerivativeOrdersToCancelUpToAmountRequest> | undefined): boolean {
    return proto3.util.equals(QueryTraderDerivativeOrdersToCancelUpToAmountRequest, a, b);
  }
}

/**
 * QueryTraderDerivativeOrdersRequest is the request type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest
 */
export class QueryTraderDerivativeOrdersRequest extends Message<QueryTraderDerivativeOrdersRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * SubaccountID of the trader
   *
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  constructor(data?: PartialMessage<QueryTraderDerivativeOrdersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraderDerivativeOrdersRequest {
    return new QueryTraderDerivativeOrdersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraderDerivativeOrdersRequest {
    return new QueryTraderDerivativeOrdersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraderDerivativeOrdersRequest {
    return new QueryTraderDerivativeOrdersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraderDerivativeOrdersRequest | PlainMessage<QueryTraderDerivativeOrdersRequest> | undefined, b: QueryTraderDerivativeOrdersRequest | PlainMessage<QueryTraderDerivativeOrdersRequest> | undefined): boolean {
    return proto3.util.equals(QueryTraderDerivativeOrdersRequest, a, b);
  }
}

/**
 * QueryAccountAddressSpotOrdersRequest is the request type for the
 * Query/AccountAddressDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest
 */
export class QueryAccountAddressDerivativeOrdersRequest extends Message<QueryAccountAddressDerivativeOrdersRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * Account address of the trader
   *
   * @generated from field: string account_address = 2;
   */
  accountAddress = "";

  constructor(data?: PartialMessage<QueryAccountAddressDerivativeOrdersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAccountAddressDerivativeOrdersRequest {
    return new QueryAccountAddressDerivativeOrdersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAccountAddressDerivativeOrdersRequest {
    return new QueryAccountAddressDerivativeOrdersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAccountAddressDerivativeOrdersRequest {
    return new QueryAccountAddressDerivativeOrdersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAccountAddressDerivativeOrdersRequest | PlainMessage<QueryAccountAddressDerivativeOrdersRequest> | undefined, b: QueryAccountAddressDerivativeOrdersRequest | PlainMessage<QueryAccountAddressDerivativeOrdersRequest> | undefined): boolean {
    return proto3.util.equals(QueryAccountAddressDerivativeOrdersRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TrimmedDerivativeLimitOrder
 */
export class TrimmedDerivativeLimitOrder extends Message<TrimmedDerivativeLimitOrder> {
  /**
   * price of the order
   *
   * @generated from field: string price = 1;
   */
  price = "";

  /**
   * quantity of the order
   *
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  /**
   * margin of the order
   *
   * @generated from field: string margin = 3;
   */
  margin = "";

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string fillable = 4;
   */
  fillable = "";

  /**
   * true if the order is a buy
   *
   * ensure omitempty is not in jsontag
   *
   * @generated from field: bool isBuy = 5;
   */
  isBuy = false;

  /**
   * @generated from field: string order_hash = 6;
   */
  orderHash = "";

  /**
   * @generated from field: string cid = 7;
   */
  cid = "";

  constructor(data?: PartialMessage<TrimmedDerivativeLimitOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TrimmedDerivativeLimitOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "order_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrimmedDerivativeLimitOrder {
    return new TrimmedDerivativeLimitOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrimmedDerivativeLimitOrder {
    return new TrimmedDerivativeLimitOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrimmedDerivativeLimitOrder {
    return new TrimmedDerivativeLimitOrder().fromJsonString(jsonString, options);
  }

  static equals(a: TrimmedDerivativeLimitOrder | PlainMessage<TrimmedDerivativeLimitOrder> | undefined, b: TrimmedDerivativeLimitOrder | PlainMessage<TrimmedDerivativeLimitOrder> | undefined): boolean {
    return proto3.util.equals(TrimmedDerivativeLimitOrder, a, b);
  }
}

/**
 * QueryTraderDerivativeOrdersResponse is the response type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse
 */
export class QueryTraderDerivativeOrdersResponse extends Message<QueryTraderDerivativeOrdersResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;
   */
  orders: TrimmedDerivativeLimitOrder[] = [];

  constructor(data?: PartialMessage<QueryTraderDerivativeOrdersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedDerivativeLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraderDerivativeOrdersResponse {
    return new QueryTraderDerivativeOrdersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraderDerivativeOrdersResponse {
    return new QueryTraderDerivativeOrdersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraderDerivativeOrdersResponse {
    return new QueryTraderDerivativeOrdersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraderDerivativeOrdersResponse | PlainMessage<QueryTraderDerivativeOrdersResponse> | undefined, b: QueryTraderDerivativeOrdersResponse | PlainMessage<QueryTraderDerivativeOrdersResponse> | undefined): boolean {
    return proto3.util.equals(QueryTraderDerivativeOrdersResponse, a, b);
  }
}

/**
 * QueryAccountAddressDerivativeOrdersResponse is the response type for the
 * Query/AccountAddressDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse
 */
export class QueryAccountAddressDerivativeOrdersResponse extends Message<QueryAccountAddressDerivativeOrdersResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;
   */
  orders: TrimmedDerivativeLimitOrder[] = [];

  constructor(data?: PartialMessage<QueryAccountAddressDerivativeOrdersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedDerivativeLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAccountAddressDerivativeOrdersResponse {
    return new QueryAccountAddressDerivativeOrdersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAccountAddressDerivativeOrdersResponse {
    return new QueryAccountAddressDerivativeOrdersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAccountAddressDerivativeOrdersResponse {
    return new QueryAccountAddressDerivativeOrdersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAccountAddressDerivativeOrdersResponse | PlainMessage<QueryAccountAddressDerivativeOrdersResponse> | undefined, b: QueryAccountAddressDerivativeOrdersResponse | PlainMessage<QueryAccountAddressDerivativeOrdersResponse> | undefined): boolean {
    return proto3.util.equals(QueryAccountAddressDerivativeOrdersResponse, a, b);
  }
}

/**
 * QueryTraderDerivativeOrdersRequest is the request type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest
 */
export class QueryDerivativeOrdersByHashesRequest extends Message<QueryDerivativeOrdersByHashesRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * SubaccountID of the trader
   *
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  /**
   * the order hashes
   *
   * @generated from field: repeated string order_hashes = 3;
   */
  orderHashes: string[] = [];

  constructor(data?: PartialMessage<QueryDerivativeOrdersByHashesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_hashes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeOrdersByHashesRequest {
    return new QueryDerivativeOrdersByHashesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeOrdersByHashesRequest {
    return new QueryDerivativeOrdersByHashesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeOrdersByHashesRequest {
    return new QueryDerivativeOrdersByHashesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeOrdersByHashesRequest | PlainMessage<QueryDerivativeOrdersByHashesRequest> | undefined, b: QueryDerivativeOrdersByHashesRequest | PlainMessage<QueryDerivativeOrdersByHashesRequest> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeOrdersByHashesRequest, a, b);
  }
}

/**
 * QueryDerivativeOrdersByHashesResponse is the response type for the
 * Query/DerivativeOrdersByHashes RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse
 */
export class QueryDerivativeOrdersByHashesResponse extends Message<QueryDerivativeOrdersByHashesResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;
   */
  orders: TrimmedDerivativeLimitOrder[] = [];

  constructor(data?: PartialMessage<QueryDerivativeOrdersByHashesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedDerivativeLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeOrdersByHashesResponse {
    return new QueryDerivativeOrdersByHashesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeOrdersByHashesResponse {
    return new QueryDerivativeOrdersByHashesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeOrdersByHashesResponse {
    return new QueryDerivativeOrdersByHashesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeOrdersByHashesResponse | PlainMessage<QueryDerivativeOrdersByHashesResponse> | undefined, b: QueryDerivativeOrdersByHashesResponse | PlainMessage<QueryDerivativeOrdersByHashesResponse> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeOrdersByHashesResponse, a, b);
  }
}

/**
 * QueryDerivativeMarketsRequest is the request type for the
 * Query/DerivativeMarkets RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketsRequest
 */
export class QueryDerivativeMarketsRequest extends Message<QueryDerivativeMarketsRequest> {
  /**
   * Status of the market, for convenience it is set to string - not enum
   *
   * @generated from field: string status = 1;
   */
  status = "";

  /**
   * Filter by market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  /**
   * Flag to return the markets mid price and top of the book buy and sell
   * orders.
   *
   * @generated from field: bool with_mid_price_and_tob = 3;
   */
  withMidPriceAndTob = false;

  constructor(data?: PartialMessage<QueryDerivativeMarketsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeMarketsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "with_mid_price_and_tob", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeMarketsRequest {
    return new QueryDerivativeMarketsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeMarketsRequest {
    return new QueryDerivativeMarketsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeMarketsRequest {
    return new QueryDerivativeMarketsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeMarketsRequest | PlainMessage<QueryDerivativeMarketsRequest> | undefined, b: QueryDerivativeMarketsRequest | PlainMessage<QueryDerivativeMarketsRequest> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeMarketsRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.PriceLevel
 */
export class PriceLevel extends Message<PriceLevel> {
  /**
   * @generated from field: string price = 1;
   */
  price = "";

  /**
   * quantity
   *
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  constructor(data?: PartialMessage<PriceLevel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.PriceLevel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceLevel {
    return new PriceLevel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceLevel {
    return new PriceLevel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceLevel {
    return new PriceLevel().fromJsonString(jsonString, options);
  }

  static equals(a: PriceLevel | PlainMessage<PriceLevel> | undefined, b: PriceLevel | PlainMessage<PriceLevel> | undefined): boolean {
    return proto3.util.equals(PriceLevel, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.PerpetualMarketState
 */
export class PerpetualMarketState extends Message<PerpetualMarketState> {
  /**
   * @generated from field: injective.exchange.v1beta1.PerpetualMarketInfo market_info = 1;
   */
  marketInfo?: PerpetualMarketInfo;

  /**
   * @generated from field: injective.exchange.v1beta1.PerpetualMarketFunding funding_info = 2;
   */
  fundingInfo?: PerpetualMarketFunding;

  constructor(data?: PartialMessage<PerpetualMarketState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.PerpetualMarketState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_info", kind: "message", T: PerpetualMarketInfo },
    { no: 2, name: "funding_info", kind: "message", T: PerpetualMarketFunding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerpetualMarketState {
    return new PerpetualMarketState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerpetualMarketState {
    return new PerpetualMarketState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerpetualMarketState {
    return new PerpetualMarketState().fromJsonString(jsonString, options);
  }

  static equals(a: PerpetualMarketState | PlainMessage<PerpetualMarketState> | undefined, b: PerpetualMarketState | PlainMessage<PerpetualMarketState> | undefined): boolean {
    return proto3.util.equals(PerpetualMarketState, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.FullDerivativeMarket
 */
export class FullDerivativeMarket extends Message<FullDerivativeMarket> {
  /**
   * @generated from field: injective.exchange.v1beta1.DerivativeMarket market = 1;
   */
  market?: DerivativeMarket;

  /**
   * @generated from oneof injective.exchange.v1beta1.FullDerivativeMarket.info
   */
  info: {
    /**
     * @generated from field: injective.exchange.v1beta1.PerpetualMarketState perpetual_info = 2;
     */
    value: PerpetualMarketState;
    case: "perpetualInfo";
  } | {
    /**
     * @generated from field: injective.exchange.v1beta1.ExpiryFuturesMarketInfo futures_info = 3;
     */
    value: ExpiryFuturesMarketInfo;
    case: "futuresInfo";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: string mark_price = 4;
   */
  markPrice = "";

  /**
   * mid_price_and_tob defines the mid price for this market and the best ask
   * and bid orders
   *
   * @generated from field: injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 5;
   */
  midPriceAndTob?: MidPriceAndTOB;

  constructor(data?: PartialMessage<FullDerivativeMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.FullDerivativeMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: DerivativeMarket },
    { no: 2, name: "perpetual_info", kind: "message", T: PerpetualMarketState, oneof: "info" },
    { no: 3, name: "futures_info", kind: "message", T: ExpiryFuturesMarketInfo, oneof: "info" },
    { no: 4, name: "mark_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "mid_price_and_tob", kind: "message", T: MidPriceAndTOB },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FullDerivativeMarket {
    return new FullDerivativeMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FullDerivativeMarket {
    return new FullDerivativeMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FullDerivativeMarket {
    return new FullDerivativeMarket().fromJsonString(jsonString, options);
  }

  static equals(a: FullDerivativeMarket | PlainMessage<FullDerivativeMarket> | undefined, b: FullDerivativeMarket | PlainMessage<FullDerivativeMarket> | undefined): boolean {
    return proto3.util.equals(FullDerivativeMarket, a, b);
  }
}

/**
 * QueryDerivativeMarketsResponse is the response type for the
 * Query/DerivativeMarkets RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketsResponse
 */
export class QueryDerivativeMarketsResponse extends Message<QueryDerivativeMarketsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.FullDerivativeMarket markets = 1;
   */
  markets: FullDerivativeMarket[] = [];

  constructor(data?: PartialMessage<QueryDerivativeMarketsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeMarketsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "markets", kind: "message", T: FullDerivativeMarket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeMarketsResponse {
    return new QueryDerivativeMarketsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeMarketsResponse {
    return new QueryDerivativeMarketsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeMarketsResponse {
    return new QueryDerivativeMarketsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeMarketsResponse | PlainMessage<QueryDerivativeMarketsResponse> | undefined, b: QueryDerivativeMarketsResponse | PlainMessage<QueryDerivativeMarketsResponse> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeMarketsResponse, a, b);
  }
}

/**
 * QueryDerivativeMarketRequest is the request type for the
 * Query/DerivativeMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketRequest
 */
export class QueryDerivativeMarketRequest extends Message<QueryDerivativeMarketRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryDerivativeMarketRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeMarketRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeMarketRequest {
    return new QueryDerivativeMarketRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeMarketRequest {
    return new QueryDerivativeMarketRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeMarketRequest {
    return new QueryDerivativeMarketRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeMarketRequest | PlainMessage<QueryDerivativeMarketRequest> | undefined, b: QueryDerivativeMarketRequest | PlainMessage<QueryDerivativeMarketRequest> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeMarketRequest, a, b);
  }
}

/**
 * QueryDerivativeMarketResponse is the response type for the
 * Query/DerivativeMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketResponse
 */
export class QueryDerivativeMarketResponse extends Message<QueryDerivativeMarketResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.FullDerivativeMarket market = 1;
   */
  market?: FullDerivativeMarket;

  constructor(data?: PartialMessage<QueryDerivativeMarketResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeMarketResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: FullDerivativeMarket },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeMarketResponse {
    return new QueryDerivativeMarketResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeMarketResponse {
    return new QueryDerivativeMarketResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeMarketResponse {
    return new QueryDerivativeMarketResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeMarketResponse | PlainMessage<QueryDerivativeMarketResponse> | undefined, b: QueryDerivativeMarketResponse | PlainMessage<QueryDerivativeMarketResponse> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeMarketResponse, a, b);
  }
}

/**
 * QueryDerivativeMarketAddressRequest is the request type for the
 * Query/DerivativeMarketAddress RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest
 */
export class QueryDerivativeMarketAddressRequest extends Message<QueryDerivativeMarketAddressRequest> {
  /**
   * Market ID for the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryDerivativeMarketAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeMarketAddressRequest {
    return new QueryDerivativeMarketAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeMarketAddressRequest {
    return new QueryDerivativeMarketAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeMarketAddressRequest {
    return new QueryDerivativeMarketAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeMarketAddressRequest | PlainMessage<QueryDerivativeMarketAddressRequest> | undefined, b: QueryDerivativeMarketAddressRequest | PlainMessage<QueryDerivativeMarketAddressRequest> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeMarketAddressRequest, a, b);
  }
}

/**
 * QueryDerivativeMarketAddressResponse is the response type for the
 * Query/DerivativeMarketAddress RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse
 */
export class QueryDerivativeMarketAddressResponse extends Message<QueryDerivativeMarketAddressResponse> {
  /**
   * address for the market
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * subaccountID for the market
   *
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  constructor(data?: PartialMessage<QueryDerivativeMarketAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryDerivativeMarketAddressResponse {
    return new QueryDerivativeMarketAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryDerivativeMarketAddressResponse {
    return new QueryDerivativeMarketAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryDerivativeMarketAddressResponse {
    return new QueryDerivativeMarketAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryDerivativeMarketAddressResponse | PlainMessage<QueryDerivativeMarketAddressResponse> | undefined, b: QueryDerivativeMarketAddressResponse | PlainMessage<QueryDerivativeMarketAddressResponse> | undefined): boolean {
    return proto3.util.equals(QueryDerivativeMarketAddressResponse, a, b);
  }
}

/**
 * QuerySubaccountTradeNonceRequest is the request type for the
 * Query/SubaccountTradeNonce RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest
 */
export class QuerySubaccountTradeNonceRequest extends Message<QuerySubaccountTradeNonceRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  constructor(data?: PartialMessage<QuerySubaccountTradeNonceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountTradeNonceRequest {
    return new QuerySubaccountTradeNonceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountTradeNonceRequest {
    return new QuerySubaccountTradeNonceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountTradeNonceRequest {
    return new QuerySubaccountTradeNonceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountTradeNonceRequest | PlainMessage<QuerySubaccountTradeNonceRequest> | undefined, b: QuerySubaccountTradeNonceRequest | PlainMessage<QuerySubaccountTradeNonceRequest> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountTradeNonceRequest, a, b);
  }
}

/**
 * QuerySubaccountPositionsRequest is the request type for the
 * Query/SubaccountPositions RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountPositionsRequest
 */
export class QuerySubaccountPositionsRequest extends Message<QuerySubaccountPositionsRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  constructor(data?: PartialMessage<QuerySubaccountPositionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountPositionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountPositionsRequest {
    return new QuerySubaccountPositionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountPositionsRequest {
    return new QuerySubaccountPositionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountPositionsRequest {
    return new QuerySubaccountPositionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountPositionsRequest | PlainMessage<QuerySubaccountPositionsRequest> | undefined, b: QuerySubaccountPositionsRequest | PlainMessage<QuerySubaccountPositionsRequest> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountPositionsRequest, a, b);
  }
}

/**
 * QuerySubaccountPositionInMarketRequest is the request type for the
 * Query/SubaccountPositionInMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest
 */
export class QuerySubaccountPositionInMarketRequest extends Message<QuerySubaccountPositionInMarketRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string market_id = 2;
   */
  marketId = "";

  constructor(data?: PartialMessage<QuerySubaccountPositionInMarketRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountPositionInMarketRequest {
    return new QuerySubaccountPositionInMarketRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountPositionInMarketRequest {
    return new QuerySubaccountPositionInMarketRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountPositionInMarketRequest {
    return new QuerySubaccountPositionInMarketRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountPositionInMarketRequest | PlainMessage<QuerySubaccountPositionInMarketRequest> | undefined, b: QuerySubaccountPositionInMarketRequest | PlainMessage<QuerySubaccountPositionInMarketRequest> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountPositionInMarketRequest, a, b);
  }
}

/**
 * QuerySubaccountEffectivePositionInMarketRequest is the request type for the
 * Query/SubaccountEffectivePositionInMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest
 */
export class QuerySubaccountEffectivePositionInMarketRequest extends Message<QuerySubaccountEffectivePositionInMarketRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string market_id = 2;
   */
  marketId = "";

  constructor(data?: PartialMessage<QuerySubaccountEffectivePositionInMarketRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountEffectivePositionInMarketRequest {
    return new QuerySubaccountEffectivePositionInMarketRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountEffectivePositionInMarketRequest {
    return new QuerySubaccountEffectivePositionInMarketRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountEffectivePositionInMarketRequest {
    return new QuerySubaccountEffectivePositionInMarketRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountEffectivePositionInMarketRequest | PlainMessage<QuerySubaccountEffectivePositionInMarketRequest> | undefined, b: QuerySubaccountEffectivePositionInMarketRequest | PlainMessage<QuerySubaccountEffectivePositionInMarketRequest> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountEffectivePositionInMarketRequest, a, b);
  }
}

/**
 * QuerySubaccountOrderMetadataRequest is the request type for the
 * Query/SubaccountOrderMetadata RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest
 */
export class QuerySubaccountOrderMetadataRequest extends Message<QuerySubaccountOrderMetadataRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  constructor(data?: PartialMessage<QuerySubaccountOrderMetadataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountOrderMetadataRequest {
    return new QuerySubaccountOrderMetadataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountOrderMetadataRequest {
    return new QuerySubaccountOrderMetadataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountOrderMetadataRequest {
    return new QuerySubaccountOrderMetadataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountOrderMetadataRequest | PlainMessage<QuerySubaccountOrderMetadataRequest> | undefined, b: QuerySubaccountOrderMetadataRequest | PlainMessage<QuerySubaccountOrderMetadataRequest> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountOrderMetadataRequest, a, b);
  }
}

/**
 * QuerySubaccountPositionsResponse is the response type for the
 * Query/SubaccountPositions RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountPositionsResponse
 */
export class QuerySubaccountPositionsResponse extends Message<QuerySubaccountPositionsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativePosition state = 1;
   */
  state: DerivativePosition[] = [];

  constructor(data?: PartialMessage<QuerySubaccountPositionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountPositionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: DerivativePosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountPositionsResponse {
    return new QuerySubaccountPositionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountPositionsResponse {
    return new QuerySubaccountPositionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountPositionsResponse {
    return new QuerySubaccountPositionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountPositionsResponse | PlainMessage<QuerySubaccountPositionsResponse> | undefined, b: QuerySubaccountPositionsResponse | PlainMessage<QuerySubaccountPositionsResponse> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountPositionsResponse, a, b);
  }
}

/**
 * QuerySubaccountPositionInMarketResponse is the response type for the
 * Query/SubaccountPositionInMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse
 */
export class QuerySubaccountPositionInMarketResponse extends Message<QuerySubaccountPositionInMarketResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.Position state = 1;
   */
  state?: Position;

  constructor(data?: PartialMessage<QuerySubaccountPositionInMarketResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: Position },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountPositionInMarketResponse {
    return new QuerySubaccountPositionInMarketResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountPositionInMarketResponse {
    return new QuerySubaccountPositionInMarketResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountPositionInMarketResponse {
    return new QuerySubaccountPositionInMarketResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountPositionInMarketResponse | PlainMessage<QuerySubaccountPositionInMarketResponse> | undefined, b: QuerySubaccountPositionInMarketResponse | PlainMessage<QuerySubaccountPositionInMarketResponse> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountPositionInMarketResponse, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.EffectivePosition
 */
export class EffectivePosition extends Message<EffectivePosition> {
  /**
   * @generated from field: bool is_long = 1;
   */
  isLong = false;

  /**
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  /**
   * @generated from field: string entry_price = 3;
   */
  entryPrice = "";

  /**
   * @generated from field: string effective_margin = 4;
   */
  effectiveMargin = "";

  constructor(data?: PartialMessage<EffectivePosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.EffectivePosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_long", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entry_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "effective_margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EffectivePosition {
    return new EffectivePosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EffectivePosition {
    return new EffectivePosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EffectivePosition {
    return new EffectivePosition().fromJsonString(jsonString, options);
  }

  static equals(a: EffectivePosition | PlainMessage<EffectivePosition> | undefined, b: EffectivePosition | PlainMessage<EffectivePosition> | undefined): boolean {
    return proto3.util.equals(EffectivePosition, a, b);
  }
}

/**
 * QuerySubaccountEffectivePositionInMarketResponse is the response type for the
 * Query/SubaccountEffectivePositionInMarket RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse
 */
export class QuerySubaccountEffectivePositionInMarketResponse extends Message<QuerySubaccountEffectivePositionInMarketResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.EffectivePosition state = 1;
   */
  state?: EffectivePosition;

  constructor(data?: PartialMessage<QuerySubaccountEffectivePositionInMarketResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: EffectivePosition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountEffectivePositionInMarketResponse {
    return new QuerySubaccountEffectivePositionInMarketResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountEffectivePositionInMarketResponse {
    return new QuerySubaccountEffectivePositionInMarketResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountEffectivePositionInMarketResponse {
    return new QuerySubaccountEffectivePositionInMarketResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountEffectivePositionInMarketResponse | PlainMessage<QuerySubaccountEffectivePositionInMarketResponse> | undefined, b: QuerySubaccountEffectivePositionInMarketResponse | PlainMessage<QuerySubaccountEffectivePositionInMarketResponse> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountEffectivePositionInMarketResponse, a, b);
  }
}

/**
 * QueryPerpetualMarketInfoRequest is the request type for the
 * Query/PerpetualMarketInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest
 */
export class QueryPerpetualMarketInfoRequest extends Message<QueryPerpetualMarketInfoRequest> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryPerpetualMarketInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPerpetualMarketInfoRequest {
    return new QueryPerpetualMarketInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPerpetualMarketInfoRequest {
    return new QueryPerpetualMarketInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPerpetualMarketInfoRequest {
    return new QueryPerpetualMarketInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPerpetualMarketInfoRequest | PlainMessage<QueryPerpetualMarketInfoRequest> | undefined, b: QueryPerpetualMarketInfoRequest | PlainMessage<QueryPerpetualMarketInfoRequest> | undefined): boolean {
    return proto3.util.equals(QueryPerpetualMarketInfoRequest, a, b);
  }
}

/**
 * QueryPerpetualMarketInfoResponse is the response type for the
 * Query/PerpetualMarketInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse
 */
export class QueryPerpetualMarketInfoResponse extends Message<QueryPerpetualMarketInfoResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.PerpetualMarketInfo info = 1;
   */
  info?: PerpetualMarketInfo;

  constructor(data?: PartialMessage<QueryPerpetualMarketInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info", kind: "message", T: PerpetualMarketInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPerpetualMarketInfoResponse {
    return new QueryPerpetualMarketInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPerpetualMarketInfoResponse {
    return new QueryPerpetualMarketInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPerpetualMarketInfoResponse {
    return new QueryPerpetualMarketInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPerpetualMarketInfoResponse | PlainMessage<QueryPerpetualMarketInfoResponse> | undefined, b: QueryPerpetualMarketInfoResponse | PlainMessage<QueryPerpetualMarketInfoResponse> | undefined): boolean {
    return proto3.util.equals(QueryPerpetualMarketInfoResponse, a, b);
  }
}

/**
 * QueryExpiryFuturesMarketInfoRequest is the request type for the Query/
 * ExpiryFuturesMarketInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest
 */
export class QueryExpiryFuturesMarketInfoRequest extends Message<QueryExpiryFuturesMarketInfoRequest> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryExpiryFuturesMarketInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryExpiryFuturesMarketInfoRequest {
    return new QueryExpiryFuturesMarketInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryExpiryFuturesMarketInfoRequest {
    return new QueryExpiryFuturesMarketInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryExpiryFuturesMarketInfoRequest {
    return new QueryExpiryFuturesMarketInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryExpiryFuturesMarketInfoRequest | PlainMessage<QueryExpiryFuturesMarketInfoRequest> | undefined, b: QueryExpiryFuturesMarketInfoRequest | PlainMessage<QueryExpiryFuturesMarketInfoRequest> | undefined): boolean {
    return proto3.util.equals(QueryExpiryFuturesMarketInfoRequest, a, b);
  }
}

/**
 * QueryExpiryFuturesMarketInfoResponse is the response type for the Query/
 * ExpiryFuturesMarketInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse
 */
export class QueryExpiryFuturesMarketInfoResponse extends Message<QueryExpiryFuturesMarketInfoResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.ExpiryFuturesMarketInfo info = 1;
   */
  info?: ExpiryFuturesMarketInfo;

  constructor(data?: PartialMessage<QueryExpiryFuturesMarketInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info", kind: "message", T: ExpiryFuturesMarketInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryExpiryFuturesMarketInfoResponse {
    return new QueryExpiryFuturesMarketInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryExpiryFuturesMarketInfoResponse {
    return new QueryExpiryFuturesMarketInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryExpiryFuturesMarketInfoResponse {
    return new QueryExpiryFuturesMarketInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryExpiryFuturesMarketInfoResponse | PlainMessage<QueryExpiryFuturesMarketInfoResponse> | undefined, b: QueryExpiryFuturesMarketInfoResponse | PlainMessage<QueryExpiryFuturesMarketInfoResponse> | undefined): boolean {
    return proto3.util.equals(QueryExpiryFuturesMarketInfoResponse, a, b);
  }
}

/**
 * QueryPerpetualMarketFundingRequest is the request type for the
 * Query/PerpetualMarketFunding RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest
 */
export class QueryPerpetualMarketFundingRequest extends Message<QueryPerpetualMarketFundingRequest> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryPerpetualMarketFundingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPerpetualMarketFundingRequest {
    return new QueryPerpetualMarketFundingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPerpetualMarketFundingRequest {
    return new QueryPerpetualMarketFundingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPerpetualMarketFundingRequest {
    return new QueryPerpetualMarketFundingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPerpetualMarketFundingRequest | PlainMessage<QueryPerpetualMarketFundingRequest> | undefined, b: QueryPerpetualMarketFundingRequest | PlainMessage<QueryPerpetualMarketFundingRequest> | undefined): boolean {
    return proto3.util.equals(QueryPerpetualMarketFundingRequest, a, b);
  }
}

/**
 * QueryPerpetualMarketFundingResponse is the response type for the
 * Query/PerpetualMarketFunding RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse
 */
export class QueryPerpetualMarketFundingResponse extends Message<QueryPerpetualMarketFundingResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.PerpetualMarketFunding state = 1;
   */
  state?: PerpetualMarketFunding;

  constructor(data?: PartialMessage<QueryPerpetualMarketFundingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: PerpetualMarketFunding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPerpetualMarketFundingResponse {
    return new QueryPerpetualMarketFundingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPerpetualMarketFundingResponse {
    return new QueryPerpetualMarketFundingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPerpetualMarketFundingResponse {
    return new QueryPerpetualMarketFundingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPerpetualMarketFundingResponse | PlainMessage<QueryPerpetualMarketFundingResponse> | undefined, b: QueryPerpetualMarketFundingResponse | PlainMessage<QueryPerpetualMarketFundingResponse> | undefined): boolean {
    return proto3.util.equals(QueryPerpetualMarketFundingResponse, a, b);
  }
}

/**
 * QuerySubaccountOrderMetadataResponse is the response type for the
 * Query/SubaccountOrderMetadata RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse
 */
export class QuerySubaccountOrderMetadataResponse extends Message<QuerySubaccountOrderMetadataResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket metadata = 1;
   */
  metadata: SubaccountOrderbookMetadataWithMarket[] = [];

  constructor(data?: PartialMessage<QuerySubaccountOrderMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: SubaccountOrderbookMetadataWithMarket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountOrderMetadataResponse {
    return new QuerySubaccountOrderMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountOrderMetadataResponse {
    return new QuerySubaccountOrderMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountOrderMetadataResponse {
    return new QuerySubaccountOrderMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountOrderMetadataResponse | PlainMessage<QuerySubaccountOrderMetadataResponse> | undefined, b: QuerySubaccountOrderMetadataResponse | PlainMessage<QuerySubaccountOrderMetadataResponse> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountOrderMetadataResponse, a, b);
  }
}

/**
 * QuerySubaccountTradeNonceResponse is the response type for the
 * Query/SubaccountTradeNonce RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse
 */
export class QuerySubaccountTradeNonceResponse extends Message<QuerySubaccountTradeNonceResponse> {
  /**
   * @generated from field: uint32 nonce = 1;
   */
  nonce = 0;

  constructor(data?: PartialMessage<QuerySubaccountTradeNonceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySubaccountTradeNonceResponse {
    return new QuerySubaccountTradeNonceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySubaccountTradeNonceResponse {
    return new QuerySubaccountTradeNonceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySubaccountTradeNonceResponse {
    return new QuerySubaccountTradeNonceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySubaccountTradeNonceResponse | PlainMessage<QuerySubaccountTradeNonceResponse> | undefined, b: QuerySubaccountTradeNonceResponse | PlainMessage<QuerySubaccountTradeNonceResponse> | undefined): boolean {
    return proto3.util.equals(QuerySubaccountTradeNonceResponse, a, b);
  }
}

/**
 * QueryModuleStateRequest is the request type for the Query/ExchangeModuleState
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryModuleStateRequest
 */
export class QueryModuleStateRequest extends Message<QueryModuleStateRequest> {
  constructor(data?: PartialMessage<QueryModuleStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryModuleStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryModuleStateRequest {
    return new QueryModuleStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryModuleStateRequest {
    return new QueryModuleStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryModuleStateRequest {
    return new QueryModuleStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryModuleStateRequest | PlainMessage<QueryModuleStateRequest> | undefined, b: QueryModuleStateRequest | PlainMessage<QueryModuleStateRequest> | undefined): boolean {
    return proto3.util.equals(QueryModuleStateRequest, a, b);
  }
}

/**
 * QueryModuleStateResponse is the response type for the
 * Query/ExchangeModuleState RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryModuleStateResponse
 */
export class QueryModuleStateResponse extends Message<QueryModuleStateResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.GenesisState state = 1;
   */
  state?: GenesisState;

  constructor(data?: PartialMessage<QueryModuleStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryModuleStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: GenesisState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryModuleStateResponse {
    return new QueryModuleStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryModuleStateResponse {
    return new QueryModuleStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryModuleStateResponse {
    return new QueryModuleStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryModuleStateResponse | PlainMessage<QueryModuleStateResponse> | undefined, b: QueryModuleStateResponse | PlainMessage<QueryModuleStateResponse> | undefined): boolean {
    return proto3.util.equals(QueryModuleStateResponse, a, b);
  }
}

/**
 * QueryPositionsRequest is the request type for the Query/Positions RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPositionsRequest
 */
export class QueryPositionsRequest extends Message<QueryPositionsRequest> {
  constructor(data?: PartialMessage<QueryPositionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryPositionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPositionsRequest {
    return new QueryPositionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPositionsRequest {
    return new QueryPositionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPositionsRequest {
    return new QueryPositionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPositionsRequest | PlainMessage<QueryPositionsRequest> | undefined, b: QueryPositionsRequest | PlainMessage<QueryPositionsRequest> | undefined): boolean {
    return proto3.util.equals(QueryPositionsRequest, a, b);
  }
}

/**
 * QueryPositionsResponse is the response type for the Query/Positions RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryPositionsResponse
 */
export class QueryPositionsResponse extends Message<QueryPositionsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.DerivativePosition state = 1;
   */
  state: DerivativePosition[] = [];

  constructor(data?: PartialMessage<QueryPositionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryPositionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "message", T: DerivativePosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPositionsResponse {
    return new QueryPositionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPositionsResponse {
    return new QueryPositionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPositionsResponse {
    return new QueryPositionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPositionsResponse | PlainMessage<QueryPositionsResponse> | undefined, b: QueryPositionsResponse | PlainMessage<QueryPositionsResponse> | undefined): boolean {
    return proto3.util.equals(QueryPositionsResponse, a, b);
  }
}

/**
 * QueryTradeRewardPointsRequest is the request type for the
 * Query/TradeRewardPoints RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTradeRewardPointsRequest
 */
export class QueryTradeRewardPointsRequest extends Message<QueryTradeRewardPointsRequest> {
  /**
   * @generated from field: repeated string accounts = 1;
   */
  accounts: string[] = [];

  /**
   * @generated from field: int64 pending_pool_timestamp = 2;
   */
  pendingPoolTimestamp = protoInt64.zero;

  constructor(data?: PartialMessage<QueryTradeRewardPointsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTradeRewardPointsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "pending_pool_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTradeRewardPointsRequest {
    return new QueryTradeRewardPointsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTradeRewardPointsRequest {
    return new QueryTradeRewardPointsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTradeRewardPointsRequest {
    return new QueryTradeRewardPointsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTradeRewardPointsRequest | PlainMessage<QueryTradeRewardPointsRequest> | undefined, b: QueryTradeRewardPointsRequest | PlainMessage<QueryTradeRewardPointsRequest> | undefined): boolean {
    return proto3.util.equals(QueryTradeRewardPointsRequest, a, b);
  }
}

/**
 * QueryTradeRewardPointsResponse is the response type for the
 * Query/TradeRewardPoints RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTradeRewardPointsResponse
 */
export class QueryTradeRewardPointsResponse extends Message<QueryTradeRewardPointsResponse> {
  /**
   * @generated from field: repeated string account_trade_reward_points = 1;
   */
  accountTradeRewardPoints: string[] = [];

  constructor(data?: PartialMessage<QueryTradeRewardPointsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTradeRewardPointsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_trade_reward_points", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTradeRewardPointsResponse {
    return new QueryTradeRewardPointsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTradeRewardPointsResponse {
    return new QueryTradeRewardPointsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTradeRewardPointsResponse {
    return new QueryTradeRewardPointsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTradeRewardPointsResponse | PlainMessage<QueryTradeRewardPointsResponse> | undefined, b: QueryTradeRewardPointsResponse | PlainMessage<QueryTradeRewardPointsResponse> | undefined): boolean {
    return proto3.util.equals(QueryTradeRewardPointsResponse, a, b);
  }
}

/**
 * QueryTradeRewardCampaignRequest is the request type for the
 * Query/TradeRewardCampaign RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTradeRewardCampaignRequest
 */
export class QueryTradeRewardCampaignRequest extends Message<QueryTradeRewardCampaignRequest> {
  constructor(data?: PartialMessage<QueryTradeRewardCampaignRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTradeRewardCampaignRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTradeRewardCampaignRequest {
    return new QueryTradeRewardCampaignRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTradeRewardCampaignRequest {
    return new QueryTradeRewardCampaignRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTradeRewardCampaignRequest {
    return new QueryTradeRewardCampaignRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTradeRewardCampaignRequest | PlainMessage<QueryTradeRewardCampaignRequest> | undefined, b: QueryTradeRewardCampaignRequest | PlainMessage<QueryTradeRewardCampaignRequest> | undefined): boolean {
    return proto3.util.equals(QueryTradeRewardCampaignRequest, a, b);
  }
}

/**
 * QueryTradeRewardCampaignResponse is the response type for the
 * Query/TradeRewardCampaign RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTradeRewardCampaignResponse
 */
export class QueryTradeRewardCampaignResponse extends Message<QueryTradeRewardCampaignResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 1;
   */
  tradingRewardCampaignInfo?: TradingRewardCampaignInfo;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 2;
   */
  tradingRewardPoolCampaignSchedule: CampaignRewardPool[] = [];

  /**
   * @generated from field: string total_trade_reward_points = 3;
   */
  totalTradeRewardPoints = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 4;
   */
  pendingTradingRewardPoolCampaignSchedule: CampaignRewardPool[] = [];

  /**
   * @generated from field: repeated string pending_total_trade_reward_points = 5;
   */
  pendingTotalTradeRewardPoints: string[] = [];

  constructor(data?: PartialMessage<QueryTradeRewardCampaignResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTradeRewardCampaignResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trading_reward_campaign_info", kind: "message", T: TradingRewardCampaignInfo },
    { no: 2, name: "trading_reward_pool_campaign_schedule", kind: "message", T: CampaignRewardPool, repeated: true },
    { no: 3, name: "total_trade_reward_points", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "pending_trading_reward_pool_campaign_schedule", kind: "message", T: CampaignRewardPool, repeated: true },
    { no: 5, name: "pending_total_trade_reward_points", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTradeRewardCampaignResponse {
    return new QueryTradeRewardCampaignResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTradeRewardCampaignResponse {
    return new QueryTradeRewardCampaignResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTradeRewardCampaignResponse {
    return new QueryTradeRewardCampaignResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTradeRewardCampaignResponse | PlainMessage<QueryTradeRewardCampaignResponse> | undefined, b: QueryTradeRewardCampaignResponse | PlainMessage<QueryTradeRewardCampaignResponse> | undefined): boolean {
    return proto3.util.equals(QueryTradeRewardCampaignResponse, a, b);
  }
}

/**
 * QueryIsRegisteredDMMRequest is the request type for the Query/IsRegisteredDMM
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest
 */
export class QueryIsOptedOutOfRewardsRequest extends Message<QueryIsOptedOutOfRewardsRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  constructor(data?: PartialMessage<QueryIsOptedOutOfRewardsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryIsOptedOutOfRewardsRequest {
    return new QueryIsOptedOutOfRewardsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryIsOptedOutOfRewardsRequest {
    return new QueryIsOptedOutOfRewardsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryIsOptedOutOfRewardsRequest {
    return new QueryIsOptedOutOfRewardsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryIsOptedOutOfRewardsRequest | PlainMessage<QueryIsOptedOutOfRewardsRequest> | undefined, b: QueryIsOptedOutOfRewardsRequest | PlainMessage<QueryIsOptedOutOfRewardsRequest> | undefined): boolean {
    return proto3.util.equals(QueryIsOptedOutOfRewardsRequest, a, b);
  }
}

/**
 * QueryIsRegisteredDMMResponse is the response type for the
 * Query/IsRegisteredDMM RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse
 */
export class QueryIsOptedOutOfRewardsResponse extends Message<QueryIsOptedOutOfRewardsResponse> {
  /**
   * @generated from field: bool is_opted_out = 1;
   */
  isOptedOut = false;

  constructor(data?: PartialMessage<QueryIsOptedOutOfRewardsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_opted_out", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryIsOptedOutOfRewardsResponse {
    return new QueryIsOptedOutOfRewardsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryIsOptedOutOfRewardsResponse {
    return new QueryIsOptedOutOfRewardsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryIsOptedOutOfRewardsResponse {
    return new QueryIsOptedOutOfRewardsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryIsOptedOutOfRewardsResponse | PlainMessage<QueryIsOptedOutOfRewardsResponse> | undefined, b: QueryIsOptedOutOfRewardsResponse | PlainMessage<QueryIsOptedOutOfRewardsResponse> | undefined): boolean {
    return proto3.util.equals(QueryIsOptedOutOfRewardsResponse, a, b);
  }
}

/**
 * QueryRegisteredDMMsRequest is the request type for the Query/RegisteredDMMs
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest
 */
export class QueryOptedOutOfRewardsAccountsRequest extends Message<QueryOptedOutOfRewardsAccountsRequest> {
  constructor(data?: PartialMessage<QueryOptedOutOfRewardsAccountsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryOptedOutOfRewardsAccountsRequest {
    return new QueryOptedOutOfRewardsAccountsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryOptedOutOfRewardsAccountsRequest {
    return new QueryOptedOutOfRewardsAccountsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryOptedOutOfRewardsAccountsRequest {
    return new QueryOptedOutOfRewardsAccountsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryOptedOutOfRewardsAccountsRequest | PlainMessage<QueryOptedOutOfRewardsAccountsRequest> | undefined, b: QueryOptedOutOfRewardsAccountsRequest | PlainMessage<QueryOptedOutOfRewardsAccountsRequest> | undefined): boolean {
    return proto3.util.equals(QueryOptedOutOfRewardsAccountsRequest, a, b);
  }
}

/**
 * QueryRegisteredDMMsResponse is the response type for the Query/RegisteredDMMs
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse
 */
export class QueryOptedOutOfRewardsAccountsResponse extends Message<QueryOptedOutOfRewardsAccountsResponse> {
  /**
   * @generated from field: repeated string accounts = 1;
   */
  accounts: string[] = [];

  constructor(data?: PartialMessage<QueryOptedOutOfRewardsAccountsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryOptedOutOfRewardsAccountsResponse {
    return new QueryOptedOutOfRewardsAccountsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryOptedOutOfRewardsAccountsResponse {
    return new QueryOptedOutOfRewardsAccountsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryOptedOutOfRewardsAccountsResponse {
    return new QueryOptedOutOfRewardsAccountsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryOptedOutOfRewardsAccountsResponse | PlainMessage<QueryOptedOutOfRewardsAccountsResponse> | undefined, b: QueryOptedOutOfRewardsAccountsResponse | PlainMessage<QueryOptedOutOfRewardsAccountsResponse> | undefined): boolean {
    return proto3.util.equals(QueryOptedOutOfRewardsAccountsResponse, a, b);
  }
}

/**
 * QueryFeeDiscountAccountInfoRequest is the request type for the
 * Query/FeeDiscountAccountInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest
 */
export class QueryFeeDiscountAccountInfoRequest extends Message<QueryFeeDiscountAccountInfoRequest> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  constructor(data?: PartialMessage<QueryFeeDiscountAccountInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFeeDiscountAccountInfoRequest {
    return new QueryFeeDiscountAccountInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFeeDiscountAccountInfoRequest {
    return new QueryFeeDiscountAccountInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFeeDiscountAccountInfoRequest {
    return new QueryFeeDiscountAccountInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFeeDiscountAccountInfoRequest | PlainMessage<QueryFeeDiscountAccountInfoRequest> | undefined, b: QueryFeeDiscountAccountInfoRequest | PlainMessage<QueryFeeDiscountAccountInfoRequest> | undefined): boolean {
    return proto3.util.equals(QueryFeeDiscountAccountInfoRequest, a, b);
  }
}

/**
 * QueryFeeDiscountAccountInfoResponse is the response type for the
 * Query/FeeDiscountAccountInfo RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse
 */
export class QueryFeeDiscountAccountInfoResponse extends Message<QueryFeeDiscountAccountInfoResponse> {
  /**
   * @generated from field: uint64 tier_level = 1;
   */
  tierLevel = protoInt64.zero;

  /**
   * @generated from field: injective.exchange.v1beta1.FeeDiscountTierInfo account_info = 2;
   */
  accountInfo?: FeeDiscountTierInfo;

  /**
   * @generated from field: injective.exchange.v1beta1.FeeDiscountTierTTL account_ttl = 3;
   */
  accountTtl?: FeeDiscountTierTTL;

  constructor(data?: PartialMessage<QueryFeeDiscountAccountInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tier_level", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "account_info", kind: "message", T: FeeDiscountTierInfo },
    { no: 3, name: "account_ttl", kind: "message", T: FeeDiscountTierTTL },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFeeDiscountAccountInfoResponse {
    return new QueryFeeDiscountAccountInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFeeDiscountAccountInfoResponse {
    return new QueryFeeDiscountAccountInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFeeDiscountAccountInfoResponse {
    return new QueryFeeDiscountAccountInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFeeDiscountAccountInfoResponse | PlainMessage<QueryFeeDiscountAccountInfoResponse> | undefined, b: QueryFeeDiscountAccountInfoResponse | PlainMessage<QueryFeeDiscountAccountInfoResponse> | undefined): boolean {
    return proto3.util.equals(QueryFeeDiscountAccountInfoResponse, a, b);
  }
}

/**
 * QueryFeeDiscountScheduleRequest is the request type for the
 * Query/FeeDiscountSchedule RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest
 */
export class QueryFeeDiscountScheduleRequest extends Message<QueryFeeDiscountScheduleRequest> {
  constructor(data?: PartialMessage<QueryFeeDiscountScheduleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFeeDiscountScheduleRequest {
    return new QueryFeeDiscountScheduleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFeeDiscountScheduleRequest {
    return new QueryFeeDiscountScheduleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFeeDiscountScheduleRequest {
    return new QueryFeeDiscountScheduleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFeeDiscountScheduleRequest | PlainMessage<QueryFeeDiscountScheduleRequest> | undefined, b: QueryFeeDiscountScheduleRequest | PlainMessage<QueryFeeDiscountScheduleRequest> | undefined): boolean {
    return proto3.util.equals(QueryFeeDiscountScheduleRequest, a, b);
  }
}

/**
 * QueryFeeDiscountScheduleResponse is the response type for the
 * Query/FeeDiscountSchedule RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse
 */
export class QueryFeeDiscountScheduleResponse extends Message<QueryFeeDiscountScheduleResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 1;
   */
  feeDiscountSchedule?: FeeDiscountSchedule;

  constructor(data?: PartialMessage<QueryFeeDiscountScheduleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fee_discount_schedule", kind: "message", T: FeeDiscountSchedule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFeeDiscountScheduleResponse {
    return new QueryFeeDiscountScheduleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFeeDiscountScheduleResponse {
    return new QueryFeeDiscountScheduleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFeeDiscountScheduleResponse {
    return new QueryFeeDiscountScheduleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFeeDiscountScheduleResponse | PlainMessage<QueryFeeDiscountScheduleResponse> | undefined, b: QueryFeeDiscountScheduleResponse | PlainMessage<QueryFeeDiscountScheduleResponse> | undefined): boolean {
    return proto3.util.equals(QueryFeeDiscountScheduleResponse, a, b);
  }
}

/**
 * QueryBalanceMismatchesRequest is the request type for the
 * Query/QueryBalanceMismatches RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBalanceMismatchesRequest
 */
export class QueryBalanceMismatchesRequest extends Message<QueryBalanceMismatchesRequest> {
  /**
   * @generated from field: int64 dust_factor = 1;
   */
  dustFactor = protoInt64.zero;

  constructor(data?: PartialMessage<QueryBalanceMismatchesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryBalanceMismatchesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dust_factor", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBalanceMismatchesRequest {
    return new QueryBalanceMismatchesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBalanceMismatchesRequest {
    return new QueryBalanceMismatchesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBalanceMismatchesRequest {
    return new QueryBalanceMismatchesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBalanceMismatchesRequest | PlainMessage<QueryBalanceMismatchesRequest> | undefined, b: QueryBalanceMismatchesRequest | PlainMessage<QueryBalanceMismatchesRequest> | undefined): boolean {
    return proto3.util.equals(QueryBalanceMismatchesRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.BalanceMismatch
 */
export class BalanceMismatch extends Message<BalanceMismatch> {
  /**
   * @generated from field: string subaccountId = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * @generated from field: string available = 3;
   */
  available = "";

  /**
   * @generated from field: string total = 4;
   */
  total = "";

  /**
   * @generated from field: string balance_hold = 5;
   */
  balanceHold = "";

  /**
   * @generated from field: string expected_total = 6;
   */
  expectedTotal = "";

  /**
   * @generated from field: string difference = 7;
   */
  difference = "";

  constructor(data?: PartialMessage<BalanceMismatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.BalanceMismatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccountId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "available", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "total", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "balance_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "expected_total", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "difference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BalanceMismatch {
    return new BalanceMismatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BalanceMismatch {
    return new BalanceMismatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BalanceMismatch {
    return new BalanceMismatch().fromJsonString(jsonString, options);
  }

  static equals(a: BalanceMismatch | PlainMessage<BalanceMismatch> | undefined, b: BalanceMismatch | PlainMessage<BalanceMismatch> | undefined): boolean {
    return proto3.util.equals(BalanceMismatch, a, b);
  }
}

/**
 * QueryBalanceMismatchesResponse is the response type for the
 * Query/QueryBalanceMismatches RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBalanceMismatchesResponse
 */
export class QueryBalanceMismatchesResponse extends Message<QueryBalanceMismatchesResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.BalanceMismatch balance_mismatches = 1;
   */
  balanceMismatches: BalanceMismatch[] = [];

  constructor(data?: PartialMessage<QueryBalanceMismatchesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryBalanceMismatchesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balance_mismatches", kind: "message", T: BalanceMismatch, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBalanceMismatchesResponse {
    return new QueryBalanceMismatchesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBalanceMismatchesResponse {
    return new QueryBalanceMismatchesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBalanceMismatchesResponse {
    return new QueryBalanceMismatchesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBalanceMismatchesResponse | PlainMessage<QueryBalanceMismatchesResponse> | undefined, b: QueryBalanceMismatchesResponse | PlainMessage<QueryBalanceMismatchesResponse> | undefined): boolean {
    return proto3.util.equals(QueryBalanceMismatchesResponse, a, b);
  }
}

/**
 * QueryBalanceWithBalanceHoldsRequest is the request type for the
 * Query/QueryBalanceWithBalanceHolds RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest
 */
export class QueryBalanceWithBalanceHoldsRequest extends Message<QueryBalanceWithBalanceHoldsRequest> {
  constructor(data?: PartialMessage<QueryBalanceWithBalanceHoldsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBalanceWithBalanceHoldsRequest {
    return new QueryBalanceWithBalanceHoldsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBalanceWithBalanceHoldsRequest {
    return new QueryBalanceWithBalanceHoldsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBalanceWithBalanceHoldsRequest {
    return new QueryBalanceWithBalanceHoldsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBalanceWithBalanceHoldsRequest | PlainMessage<QueryBalanceWithBalanceHoldsRequest> | undefined, b: QueryBalanceWithBalanceHoldsRequest | PlainMessage<QueryBalanceWithBalanceHoldsRequest> | undefined): boolean {
    return proto3.util.equals(QueryBalanceWithBalanceHoldsRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.BalanceWithMarginHold
 */
export class BalanceWithMarginHold extends Message<BalanceWithMarginHold> {
  /**
   * @generated from field: string subaccountId = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * @generated from field: string available = 3;
   */
  available = "";

  /**
   * @generated from field: string total = 4;
   */
  total = "";

  /**
   * @generated from field: string balance_hold = 5;
   */
  balanceHold = "";

  constructor(data?: PartialMessage<BalanceWithMarginHold>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.BalanceWithMarginHold";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccountId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "available", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "total", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "balance_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BalanceWithMarginHold {
    return new BalanceWithMarginHold().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BalanceWithMarginHold {
    return new BalanceWithMarginHold().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BalanceWithMarginHold {
    return new BalanceWithMarginHold().fromJsonString(jsonString, options);
  }

  static equals(a: BalanceWithMarginHold | PlainMessage<BalanceWithMarginHold> | undefined, b: BalanceWithMarginHold | PlainMessage<BalanceWithMarginHold> | undefined): boolean {
    return proto3.util.equals(BalanceWithMarginHold, a, b);
  }
}

/**
 * QueryBalanceWithBalanceHoldsResponse is the response type for the
 * Query/QueryBalanceWithBalanceHolds RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse
 */
export class QueryBalanceWithBalanceHoldsResponse extends Message<QueryBalanceWithBalanceHoldsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.BalanceWithMarginHold balance_with_balance_holds = 1;
   */
  balanceWithBalanceHolds: BalanceWithMarginHold[] = [];

  constructor(data?: PartialMessage<QueryBalanceWithBalanceHoldsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "balance_with_balance_holds", kind: "message", T: BalanceWithMarginHold, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBalanceWithBalanceHoldsResponse {
    return new QueryBalanceWithBalanceHoldsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBalanceWithBalanceHoldsResponse {
    return new QueryBalanceWithBalanceHoldsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBalanceWithBalanceHoldsResponse {
    return new QueryBalanceWithBalanceHoldsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBalanceWithBalanceHoldsResponse | PlainMessage<QueryBalanceWithBalanceHoldsResponse> | undefined, b: QueryBalanceWithBalanceHoldsResponse | PlainMessage<QueryBalanceWithBalanceHoldsResponse> | undefined): boolean {
    return proto3.util.equals(QueryBalanceWithBalanceHoldsResponse, a, b);
  }
}

/**
 * QueryFeeDiscountTierStatisticsRequest is the request type for the
 * Query/QueryFeeDiscountTierStatistics RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest
 */
export class QueryFeeDiscountTierStatisticsRequest extends Message<QueryFeeDiscountTierStatisticsRequest> {
  constructor(data?: PartialMessage<QueryFeeDiscountTierStatisticsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFeeDiscountTierStatisticsRequest {
    return new QueryFeeDiscountTierStatisticsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFeeDiscountTierStatisticsRequest {
    return new QueryFeeDiscountTierStatisticsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFeeDiscountTierStatisticsRequest {
    return new QueryFeeDiscountTierStatisticsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFeeDiscountTierStatisticsRequest | PlainMessage<QueryFeeDiscountTierStatisticsRequest> | undefined, b: QueryFeeDiscountTierStatisticsRequest | PlainMessage<QueryFeeDiscountTierStatisticsRequest> | undefined): boolean {
    return proto3.util.equals(QueryFeeDiscountTierStatisticsRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TierStatistic
 */
export class TierStatistic extends Message<TierStatistic> {
  /**
   * @generated from field: uint64 tier = 1;
   */
  tier = protoInt64.zero;

  /**
   * @generated from field: uint64 count = 2;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<TierStatistic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TierStatistic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tier", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TierStatistic {
    return new TierStatistic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TierStatistic {
    return new TierStatistic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TierStatistic {
    return new TierStatistic().fromJsonString(jsonString, options);
  }

  static equals(a: TierStatistic | PlainMessage<TierStatistic> | undefined, b: TierStatistic | PlainMessage<TierStatistic> | undefined): boolean {
    return proto3.util.equals(TierStatistic, a, b);
  }
}

/**
 * QueryFeeDiscountTierStatisticsResponse is the response type for the
 * Query/QueryFeeDiscountTierStatistics RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse
 */
export class QueryFeeDiscountTierStatisticsResponse extends Message<QueryFeeDiscountTierStatisticsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TierStatistic statistics = 1;
   */
  statistics: TierStatistic[] = [];

  constructor(data?: PartialMessage<QueryFeeDiscountTierStatisticsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statistics", kind: "message", T: TierStatistic, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFeeDiscountTierStatisticsResponse {
    return new QueryFeeDiscountTierStatisticsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFeeDiscountTierStatisticsResponse {
    return new QueryFeeDiscountTierStatisticsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFeeDiscountTierStatisticsResponse {
    return new QueryFeeDiscountTierStatisticsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFeeDiscountTierStatisticsResponse | PlainMessage<QueryFeeDiscountTierStatisticsResponse> | undefined, b: QueryFeeDiscountTierStatisticsResponse | PlainMessage<QueryFeeDiscountTierStatisticsResponse> | undefined): boolean {
    return proto3.util.equals(QueryFeeDiscountTierStatisticsResponse, a, b);
  }
}

/**
 * MitoVaultInfosRequest is the request type for the Query/MitoVaultInfos RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.MitoVaultInfosRequest
 */
export class MitoVaultInfosRequest extends Message<MitoVaultInfosRequest> {
  constructor(data?: PartialMessage<MitoVaultInfosRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.MitoVaultInfosRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MitoVaultInfosRequest {
    return new MitoVaultInfosRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MitoVaultInfosRequest {
    return new MitoVaultInfosRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MitoVaultInfosRequest {
    return new MitoVaultInfosRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MitoVaultInfosRequest | PlainMessage<MitoVaultInfosRequest> | undefined, b: MitoVaultInfosRequest | PlainMessage<MitoVaultInfosRequest> | undefined): boolean {
    return proto3.util.equals(MitoVaultInfosRequest, a, b);
  }
}

/**
 * MitoVaultInfosResponse is the response type for the Query/MitoVaultInfos RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.MitoVaultInfosResponse
 */
export class MitoVaultInfosResponse extends Message<MitoVaultInfosResponse> {
  /**
   * @generated from field: repeated string master_addresses = 1;
   */
  masterAddresses: string[] = [];

  /**
   * @generated from field: repeated string derivative_addresses = 2;
   */
  derivativeAddresses: string[] = [];

  /**
   * @generated from field: repeated string spot_addresses = 3;
   */
  spotAddresses: string[] = [];

  /**
   * @generated from field: repeated string cw20_addresses = 4;
   */
  cw20Addresses: string[] = [];

  constructor(data?: PartialMessage<MitoVaultInfosResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.MitoVaultInfosResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "master_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "derivative_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "spot_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "cw20_addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MitoVaultInfosResponse {
    return new MitoVaultInfosResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MitoVaultInfosResponse {
    return new MitoVaultInfosResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MitoVaultInfosResponse {
    return new MitoVaultInfosResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MitoVaultInfosResponse | PlainMessage<MitoVaultInfosResponse> | undefined, b: MitoVaultInfosResponse | PlainMessage<MitoVaultInfosResponse> | undefined): boolean {
    return proto3.util.equals(MitoVaultInfosResponse, a, b);
  }
}

/**
 * QueryMarketIDFromVaultRequest is the request type for the
 * Query/QueryMarketIDFromVault RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryMarketIDFromVaultRequest
 */
export class QueryMarketIDFromVaultRequest extends Message<QueryMarketIDFromVaultRequest> {
  /**
   * @generated from field: string vault_address = 1;
   */
  vaultAddress = "";

  constructor(data?: PartialMessage<QueryMarketIDFromVaultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryMarketIDFromVaultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryMarketIDFromVaultRequest {
    return new QueryMarketIDFromVaultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryMarketIDFromVaultRequest {
    return new QueryMarketIDFromVaultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryMarketIDFromVaultRequest {
    return new QueryMarketIDFromVaultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryMarketIDFromVaultRequest | PlainMessage<QueryMarketIDFromVaultRequest> | undefined, b: QueryMarketIDFromVaultRequest | PlainMessage<QueryMarketIDFromVaultRequest> | undefined): boolean {
    return proto3.util.equals(QueryMarketIDFromVaultRequest, a, b);
  }
}

/**
 * QueryMarketIDFromVaultResponse is the response type for the
 * Query/QueryMarketIDFromVault RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryMarketIDFromVaultResponse
 */
export class QueryMarketIDFromVaultResponse extends Message<QueryMarketIDFromVaultResponse> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryMarketIDFromVaultResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryMarketIDFromVaultResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryMarketIDFromVaultResponse {
    return new QueryMarketIDFromVaultResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryMarketIDFromVaultResponse {
    return new QueryMarketIDFromVaultResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryMarketIDFromVaultResponse {
    return new QueryMarketIDFromVaultResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryMarketIDFromVaultResponse | PlainMessage<QueryMarketIDFromVaultResponse> | undefined, b: QueryMarketIDFromVaultResponse | PlainMessage<QueryMarketIDFromVaultResponse> | undefined): boolean {
    return proto3.util.equals(QueryMarketIDFromVaultResponse, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest
 */
export class QueryHistoricalTradeRecordsRequest extends Message<QueryHistoricalTradeRecordsRequest> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryHistoricalTradeRecordsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryHistoricalTradeRecordsRequest {
    return new QueryHistoricalTradeRecordsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryHistoricalTradeRecordsRequest {
    return new QueryHistoricalTradeRecordsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryHistoricalTradeRecordsRequest {
    return new QueryHistoricalTradeRecordsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryHistoricalTradeRecordsRequest | PlainMessage<QueryHistoricalTradeRecordsRequest> | undefined, b: QueryHistoricalTradeRecordsRequest | PlainMessage<QueryHistoricalTradeRecordsRequest> | undefined): boolean {
    return proto3.util.equals(QueryHistoricalTradeRecordsRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse
 */
export class QueryHistoricalTradeRecordsResponse extends Message<QueryHistoricalTradeRecordsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TradeRecords trade_records = 1;
   */
  tradeRecords: TradeRecords[] = [];

  constructor(data?: PartialMessage<QueryHistoricalTradeRecordsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trade_records", kind: "message", T: TradeRecords, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryHistoricalTradeRecordsResponse {
    return new QueryHistoricalTradeRecordsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryHistoricalTradeRecordsResponse {
    return new QueryHistoricalTradeRecordsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryHistoricalTradeRecordsResponse {
    return new QueryHistoricalTradeRecordsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryHistoricalTradeRecordsResponse | PlainMessage<QueryHistoricalTradeRecordsResponse> | undefined, b: QueryHistoricalTradeRecordsResponse | PlainMessage<QueryHistoricalTradeRecordsResponse> | undefined): boolean {
    return proto3.util.equals(QueryHistoricalTradeRecordsResponse, a, b);
  }
}

/**
 * TradeHistoryOptions are the optional params for Query/MarketVolatility RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.TradeHistoryOptions
 */
export class TradeHistoryOptions extends Message<TradeHistoryOptions> {
  /**
   * TradeGroupingSec of 0 means use the chain's default grouping
   *
   * @generated from field: uint64 trade_grouping_sec = 1;
   */
  tradeGroupingSec = protoInt64.zero;

  /**
   * MaxAge restricts the trade records oldest age in seconds from the current
   * block time to consider. A value of 0 means use all the records present on
   * the chain.
   *
   * @generated from field: uint64 max_age = 2;
   */
  maxAge = protoInt64.zero;

  /**
   * If IncludeRawHistory is true, the raw underlying data used for the
   * computation is included in the response
   *
   * @generated from field: bool include_raw_history = 4;
   */
  includeRawHistory = false;

  /**
   * If IncludeMetadata is true, metadata on the computation is included in the
   * response
   *
   * @generated from field: bool include_metadata = 5;
   */
  includeMetadata = false;

  constructor(data?: PartialMessage<TradeHistoryOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TradeHistoryOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trade_grouping_sec", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "max_age", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "include_raw_history", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "include_metadata", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradeHistoryOptions {
    return new TradeHistoryOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradeHistoryOptions {
    return new TradeHistoryOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradeHistoryOptions {
    return new TradeHistoryOptions().fromJsonString(jsonString, options);
  }

  static equals(a: TradeHistoryOptions | PlainMessage<TradeHistoryOptions> | undefined, b: TradeHistoryOptions | PlainMessage<TradeHistoryOptions> | undefined): boolean {
    return proto3.util.equals(TradeHistoryOptions, a, b);
  }
}

/**
 * QueryMarketVolatilityRequest are the request params for the
 * Query/MarketVolatility RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryMarketVolatilityRequest
 */
export class QueryMarketVolatilityRequest extends Message<QueryMarketVolatilityRequest> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v1beta1.TradeHistoryOptions trade_history_options = 2;
   */
  tradeHistoryOptions?: TradeHistoryOptions;

  constructor(data?: PartialMessage<QueryMarketVolatilityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryMarketVolatilityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "trade_history_options", kind: "message", T: TradeHistoryOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryMarketVolatilityRequest {
    return new QueryMarketVolatilityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryMarketVolatilityRequest {
    return new QueryMarketVolatilityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryMarketVolatilityRequest {
    return new QueryMarketVolatilityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryMarketVolatilityRequest | PlainMessage<QueryMarketVolatilityRequest> | undefined, b: QueryMarketVolatilityRequest | PlainMessage<QueryMarketVolatilityRequest> | undefined): boolean {
    return proto3.util.equals(QueryMarketVolatilityRequest, a, b);
  }
}

/**
 * QueryMarketVolatilityResponse is the response type for the
 * Query/MarketVolatility RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryMarketVolatilityResponse
 */
export class QueryMarketVolatilityResponse extends Message<QueryMarketVolatilityResponse> {
  /**
   * @generated from field: string volatility = 1;
   */
  volatility = "";

  /**
   * @generated from field: injective.oracle.v1beta1.MetadataStatistics history_metadata = 2;
   */
  historyMetadata?: MetadataStatistics;

  /**
   * @generated from field: repeated injective.exchange.v1beta1.TradeRecord raw_history = 3;
   */
  rawHistory: TradeRecord[] = [];

  constructor(data?: PartialMessage<QueryMarketVolatilityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryMarketVolatilityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "volatility", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "history_metadata", kind: "message", T: MetadataStatistics },
    { no: 3, name: "raw_history", kind: "message", T: TradeRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryMarketVolatilityResponse {
    return new QueryMarketVolatilityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryMarketVolatilityResponse {
    return new QueryMarketVolatilityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryMarketVolatilityResponse {
    return new QueryMarketVolatilityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryMarketVolatilityResponse | PlainMessage<QueryMarketVolatilityResponse> | undefined, b: QueryMarketVolatilityResponse | PlainMessage<QueryMarketVolatilityResponse> | undefined): boolean {
    return proto3.util.equals(QueryMarketVolatilityResponse, a, b);
  }
}

/**
 * QuerBinaryMarketsRequest is the request type for the Query/BinaryMarkets RPC
 * method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBinaryMarketsRequest
 */
export class QueryBinaryMarketsRequest extends Message<QueryBinaryMarketsRequest> {
  /**
   * Status of the market, for convenience it is set to string - not enum
   *
   * @generated from field: string status = 1;
   */
  status = "";

  constructor(data?: PartialMessage<QueryBinaryMarketsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryBinaryMarketsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBinaryMarketsRequest {
    return new QueryBinaryMarketsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBinaryMarketsRequest {
    return new QueryBinaryMarketsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBinaryMarketsRequest {
    return new QueryBinaryMarketsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBinaryMarketsRequest | PlainMessage<QueryBinaryMarketsRequest> | undefined, b: QueryBinaryMarketsRequest | PlainMessage<QueryBinaryMarketsRequest> | undefined): boolean {
    return proto3.util.equals(QueryBinaryMarketsRequest, a, b);
  }
}

/**
 * QueryBinaryMarketsResponse is the response type for the Query/BinaryMarkets
 * RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryBinaryMarketsResponse
 */
export class QueryBinaryMarketsResponse extends Message<QueryBinaryMarketsResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.BinaryOptionsMarket markets = 1;
   */
  markets: BinaryOptionsMarket[] = [];

  constructor(data?: PartialMessage<QueryBinaryMarketsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryBinaryMarketsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "markets", kind: "message", T: BinaryOptionsMarket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBinaryMarketsResponse {
    return new QueryBinaryMarketsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBinaryMarketsResponse {
    return new QueryBinaryMarketsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBinaryMarketsResponse {
    return new QueryBinaryMarketsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBinaryMarketsResponse | PlainMessage<QueryBinaryMarketsResponse> | undefined, b: QueryBinaryMarketsResponse | PlainMessage<QueryBinaryMarketsResponse> | undefined): boolean {
    return proto3.util.equals(QueryBinaryMarketsResponse, a, b);
  }
}

/**
 * QueryConditionalOrdersRequest is the request type for the
 * Query/ConditionalOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest
 */
export class QueryTraderDerivativeConditionalOrdersRequest extends Message<QueryTraderDerivativeConditionalOrdersRequest> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: string market_id = 2;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryTraderDerivativeConditionalOrdersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraderDerivativeConditionalOrdersRequest {
    return new QueryTraderDerivativeConditionalOrdersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraderDerivativeConditionalOrdersRequest {
    return new QueryTraderDerivativeConditionalOrdersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraderDerivativeConditionalOrdersRequest {
    return new QueryTraderDerivativeConditionalOrdersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraderDerivativeConditionalOrdersRequest | PlainMessage<QueryTraderDerivativeConditionalOrdersRequest> | undefined, b: QueryTraderDerivativeConditionalOrdersRequest | PlainMessage<QueryTraderDerivativeConditionalOrdersRequest> | undefined): boolean {
    return proto3.util.equals(QueryTraderDerivativeConditionalOrdersRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder
 */
export class TrimmedDerivativeConditionalOrder extends Message<TrimmedDerivativeConditionalOrder> {
  /**
   * price of the order
   *
   * @generated from field: string price = 1;
   */
  price = "";

  /**
   * quantity of the order
   *
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  /**
   * margin of the order
   *
   * @generated from field: string margin = 3;
   */
  margin = "";

  /**
   * price to trigger the order
   *
   * @generated from field: string triggerPrice = 4;
   */
  triggerPrice = "";

  /**
   * true if the order is a buy
   *
   * ensure omitempty is not in jsontag
   *
   * @generated from field: bool isBuy = 5;
   */
  isBuy = false;

  /**
   * @generated from field: bool isLimit = 6;
   */
  isLimit = false;

  /**
   * @generated from field: string order_hash = 7;
   */
  orderHash = "";

  /**
   * @generated from field: string cid = 8;
   */
  cid = "";

  constructor(data?: PartialMessage<TrimmedDerivativeConditionalOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "triggerPrice", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "isLimit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "order_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrimmedDerivativeConditionalOrder {
    return new TrimmedDerivativeConditionalOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrimmedDerivativeConditionalOrder {
    return new TrimmedDerivativeConditionalOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrimmedDerivativeConditionalOrder {
    return new TrimmedDerivativeConditionalOrder().fromJsonString(jsonString, options);
  }

  static equals(a: TrimmedDerivativeConditionalOrder | PlainMessage<TrimmedDerivativeConditionalOrder> | undefined, b: TrimmedDerivativeConditionalOrder | PlainMessage<TrimmedDerivativeConditionalOrder> | undefined): boolean {
    return proto3.util.equals(TrimmedDerivativeConditionalOrder, a, b);
  }
}

/**
 * QueryTraderDerivativeOrdersResponse is the response type for the
 * Query/TraderDerivativeOrders RPC method.
 *
 * @generated from message injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse
 */
export class QueryTraderDerivativeConditionalOrdersResponse extends Message<QueryTraderDerivativeConditionalOrdersResponse> {
  /**
   * @generated from field: repeated injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder orders = 1;
   */
  orders: TrimmedDerivativeConditionalOrder[] = [];

  constructor(data?: PartialMessage<QueryTraderDerivativeConditionalOrdersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orders", kind: "message", T: TrimmedDerivativeConditionalOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraderDerivativeConditionalOrdersResponse {
    return new QueryTraderDerivativeConditionalOrdersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraderDerivativeConditionalOrdersResponse {
    return new QueryTraderDerivativeConditionalOrdersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraderDerivativeConditionalOrdersResponse {
    return new QueryTraderDerivativeConditionalOrdersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraderDerivativeConditionalOrdersResponse | PlainMessage<QueryTraderDerivativeConditionalOrdersResponse> | undefined, b: QueryTraderDerivativeConditionalOrdersResponse | PlainMessage<QueryTraderDerivativeConditionalOrdersResponse> | undefined): boolean {
    return proto3.util.equals(QueryTraderDerivativeConditionalOrdersResponse, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest
 */
export class QueryMarketAtomicExecutionFeeMultiplierRequest extends Message<QueryMarketAtomicExecutionFeeMultiplierRequest> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  constructor(data?: PartialMessage<QueryMarketAtomicExecutionFeeMultiplierRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryMarketAtomicExecutionFeeMultiplierRequest {
    return new QueryMarketAtomicExecutionFeeMultiplierRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryMarketAtomicExecutionFeeMultiplierRequest {
    return new QueryMarketAtomicExecutionFeeMultiplierRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryMarketAtomicExecutionFeeMultiplierRequest {
    return new QueryMarketAtomicExecutionFeeMultiplierRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryMarketAtomicExecutionFeeMultiplierRequest | PlainMessage<QueryMarketAtomicExecutionFeeMultiplierRequest> | undefined, b: QueryMarketAtomicExecutionFeeMultiplierRequest | PlainMessage<QueryMarketAtomicExecutionFeeMultiplierRequest> | undefined): boolean {
    return proto3.util.equals(QueryMarketAtomicExecutionFeeMultiplierRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse
 */
export class QueryMarketAtomicExecutionFeeMultiplierResponse extends Message<QueryMarketAtomicExecutionFeeMultiplierResponse> {
  /**
   * @generated from field: string multiplier = 1;
   */
  multiplier = "";

  constructor(data?: PartialMessage<QueryMarketAtomicExecutionFeeMultiplierResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryMarketAtomicExecutionFeeMultiplierResponse {
    return new QueryMarketAtomicExecutionFeeMultiplierResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryMarketAtomicExecutionFeeMultiplierResponse {
    return new QueryMarketAtomicExecutionFeeMultiplierResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryMarketAtomicExecutionFeeMultiplierResponse {
    return new QueryMarketAtomicExecutionFeeMultiplierResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryMarketAtomicExecutionFeeMultiplierResponse | PlainMessage<QueryMarketAtomicExecutionFeeMultiplierResponse> | undefined, b: QueryMarketAtomicExecutionFeeMultiplierResponse | PlainMessage<QueryMarketAtomicExecutionFeeMultiplierResponse> | undefined): boolean {
    return proto3.util.equals(QueryMarketAtomicExecutionFeeMultiplierResponse, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryActiveStakeGrantRequest
 */
export class QueryActiveStakeGrantRequest extends Message<QueryActiveStakeGrantRequest> {
  /**
   * @generated from field: string grantee = 1;
   */
  grantee = "";

  constructor(data?: PartialMessage<QueryActiveStakeGrantRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryActiveStakeGrantRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "grantee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryActiveStakeGrantRequest {
    return new QueryActiveStakeGrantRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryActiveStakeGrantRequest {
    return new QueryActiveStakeGrantRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryActiveStakeGrantRequest {
    return new QueryActiveStakeGrantRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryActiveStakeGrantRequest | PlainMessage<QueryActiveStakeGrantRequest> | undefined, b: QueryActiveStakeGrantRequest | PlainMessage<QueryActiveStakeGrantRequest> | undefined): boolean {
    return proto3.util.equals(QueryActiveStakeGrantRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryActiveStakeGrantResponse
 */
export class QueryActiveStakeGrantResponse extends Message<QueryActiveStakeGrantResponse> {
  /**
   * @generated from field: injective.exchange.v1beta1.ActiveGrant grant = 1;
   */
  grant?: ActiveGrant;

  /**
   * @generated from field: injective.exchange.v1beta1.EffectiveGrant effective_grant = 2;
   */
  effectiveGrant?: EffectiveGrant;

  constructor(data?: PartialMessage<QueryActiveStakeGrantResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryActiveStakeGrantResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "grant", kind: "message", T: ActiveGrant },
    { no: 2, name: "effective_grant", kind: "message", T: EffectiveGrant },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryActiveStakeGrantResponse {
    return new QueryActiveStakeGrantResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryActiveStakeGrantResponse {
    return new QueryActiveStakeGrantResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryActiveStakeGrantResponse {
    return new QueryActiveStakeGrantResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryActiveStakeGrantResponse | PlainMessage<QueryActiveStakeGrantResponse> | undefined, b: QueryActiveStakeGrantResponse | PlainMessage<QueryActiveStakeGrantResponse> | undefined): boolean {
    return proto3.util.equals(QueryActiveStakeGrantResponse, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryGrantAuthorizationRequest
 */
export class QueryGrantAuthorizationRequest extends Message<QueryGrantAuthorizationRequest> {
  /**
   * @generated from field: string granter = 1;
   */
  granter = "";

  /**
   * @generated from field: string grantee = 2;
   */
  grantee = "";

  constructor(data?: PartialMessage<QueryGrantAuthorizationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryGrantAuthorizationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "granter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "grantee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryGrantAuthorizationRequest {
    return new QueryGrantAuthorizationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryGrantAuthorizationRequest {
    return new QueryGrantAuthorizationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryGrantAuthorizationRequest {
    return new QueryGrantAuthorizationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryGrantAuthorizationRequest | PlainMessage<QueryGrantAuthorizationRequest> | undefined, b: QueryGrantAuthorizationRequest | PlainMessage<QueryGrantAuthorizationRequest> | undefined): boolean {
    return proto3.util.equals(QueryGrantAuthorizationRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryGrantAuthorizationResponse
 */
export class QueryGrantAuthorizationResponse extends Message<QueryGrantAuthorizationResponse> {
  /**
   * @generated from field: string amount = 1;
   */
  amount = "";

  constructor(data?: PartialMessage<QueryGrantAuthorizationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryGrantAuthorizationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryGrantAuthorizationResponse {
    return new QueryGrantAuthorizationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryGrantAuthorizationResponse {
    return new QueryGrantAuthorizationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryGrantAuthorizationResponse {
    return new QueryGrantAuthorizationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryGrantAuthorizationResponse | PlainMessage<QueryGrantAuthorizationResponse> | undefined, b: QueryGrantAuthorizationResponse | PlainMessage<QueryGrantAuthorizationResponse> | undefined): boolean {
    return proto3.util.equals(QueryGrantAuthorizationResponse, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryGrantAuthorizationsRequest
 */
export class QueryGrantAuthorizationsRequest extends Message<QueryGrantAuthorizationsRequest> {
  /**
   * @generated from field: string granter = 1;
   */
  granter = "";

  constructor(data?: PartialMessage<QueryGrantAuthorizationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryGrantAuthorizationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "granter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryGrantAuthorizationsRequest {
    return new QueryGrantAuthorizationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryGrantAuthorizationsRequest {
    return new QueryGrantAuthorizationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryGrantAuthorizationsRequest {
    return new QueryGrantAuthorizationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryGrantAuthorizationsRequest | PlainMessage<QueryGrantAuthorizationsRequest> | undefined, b: QueryGrantAuthorizationsRequest | PlainMessage<QueryGrantAuthorizationsRequest> | undefined): boolean {
    return proto3.util.equals(QueryGrantAuthorizationsRequest, a, b);
  }
}

/**
 * @generated from message injective.exchange.v1beta1.QueryGrantAuthorizationsResponse
 */
export class QueryGrantAuthorizationsResponse extends Message<QueryGrantAuthorizationsResponse> {
  /**
   * @generated from field: string total_grant_amount = 1;
   */
  totalGrantAmount = "";

  /**
   * @generated from field: repeated injective.exchange.v1beta1.GrantAuthorization grants = 2;
   */
  grants: GrantAuthorization[] = [];

  constructor(data?: PartialMessage<QueryGrantAuthorizationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v1beta1.QueryGrantAuthorizationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_grant_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "grants", kind: "message", T: GrantAuthorization, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryGrantAuthorizationsResponse {
    return new QueryGrantAuthorizationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryGrantAuthorizationsResponse {
    return new QueryGrantAuthorizationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryGrantAuthorizationsResponse {
    return new QueryGrantAuthorizationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryGrantAuthorizationsResponse | PlainMessage<QueryGrantAuthorizationsResponse> | undefined, b: QueryGrantAuthorizationsResponse | PlainMessage<QueryGrantAuthorizationsResponse> | undefined): boolean {
    return proto3.util.equals(QueryGrantAuthorizationsResponse, a, b);
  }
}

